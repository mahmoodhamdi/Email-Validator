# Milestone 6.2: CLI Tool

> **Phase:** 6 - DevOps & Deployment
> **Status:** COMPLETED
> **Priority:** MEDIUM
> **Complexity:** Medium
> **Estimated Time:** 4-5 hours

---

## Prompt for Claude Code

```
You are working on the Email Validator project. Your task is to create a CLI tool for email validation.

IMPORTANT INSTRUCTIONS:
1. Read this entire file before starting
2. Follow the implementation steps in order
3. Write tests for all new functionality
4. Update the checklist as you complete each task
5. Commit after completing with message: "feat: add CLI tool for command-line email validation"
6. Push the changes

PROJECT CONTEXT:
- This is a Next.js 14 application with existing validation logic
- Core validation is in src/lib/validators/
- The CLI should reuse existing validation functions
- Target: Publishable to npm as @email-validator/cli
```

---

## Objective

Create a command-line interface tool that:
- Validates single emails from command line
- Validates bulk emails from file input
- Outputs results in JSON, CSV, or table format
- Shows progress for bulk operations
- Can be installed globally via npm

---

## Implementation Steps

### Step 1: Create CLI Package Structure

Create the following structure:
```
cli/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts          # Main entry point
â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”œâ”€â”€ validate.ts   # Single email validation
â”‚   â”‚   â””â”€â”€ bulk.ts       # Bulk file validation
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ output.ts     # Output formatting
â”‚   â”‚   â”œâ”€â”€ progress.ts   # Progress indicators
â”‚   â”‚   â””â”€â”€ file.ts       # File reading utilities
â”‚   â””â”€â”€ types.ts          # CLI-specific types
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ README.md
â””â”€â”€ bin/
    â””â”€â”€ email-validator   # Executable entry
```

### Step 2: Create CLI package.json

Create `cli/package.json`:

```json
{
  "name": "@email-validator/cli",
  "version": "1.0.0",
  "description": "Command-line tool for email validation",
  "main": "dist/index.js",
  "bin": {
    "email-validator": "./bin/email-validator",
    "ev": "./bin/email-validator"
  },
  "scripts": {
    "build": "tsc",
    "dev": "ts-node src/index.ts",
    "test": "jest",
    "prepublishOnly": "npm run build"
  },
  "keywords": [
    "email",
    "validator",
    "cli",
    "validation"
  ],
  "author": "Mahmood Hamdi <hmdy7486@gmail.com>",
  "license": "MIT",
  "dependencies": {
    "chalk": "^5.3.0",
    "commander": "^12.0.0",
    "cli-progress": "^3.12.0",
    "cli-table3": "^0.6.3",
    "ora": "^8.0.1"
  },
  "devDependencies": {
    "@types/cli-progress": "^3.11.5",
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "files": [
    "dist",
    "bin"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/mahmoodhamdi/Email-Validator.git",
    "directory": "cli"
  }
}
```

### Step 3: Create Main CLI Entry Point

Create `cli/src/index.ts`:

```typescript
#!/usr/bin/env node

import { Command } from 'commander';
import chalk from 'chalk';
import { validateCommand } from './commands/validate';
import { bulkCommand } from './commands/bulk';

const program = new Command();

program
  .name('email-validator')
  .description('CLI tool for validating email addresses')
  .version('1.0.0');

// Single email validation
program
  .command('validate <email>')
  .alias('v')
  .description('Validate a single email address')
  .option('-f, --format <format>', 'Output format: json, table, simple', 'simple')
  .option('-v, --verbose', 'Show detailed validation checks')
  .action(validateCommand);

// Bulk validation from file
program
  .command('bulk <file>')
  .alias('b')
  .description('Validate emails from a file (one per line, or CSV)')
  .option('-o, --output <file>', 'Output file path')
  .option('-f, --format <format>', 'Output format: json, csv, table', 'table')
  .option('--filter <filter>', 'Filter results: all, valid, invalid, risky', 'all')
  .option('--no-progress', 'Disable progress bar')
  .option('-c, --concurrency <number>', 'Concurrent validations', '10')
  .action(bulkCommand);

// Show examples
program
  .command('examples')
  .description('Show usage examples')
  .action(() => {
    console.log(chalk.bold('\nExamples:\n'));
    console.log(chalk.cyan('  # Validate a single email'));
    console.log('  $ email-validator validate user@example.com\n');
    console.log(chalk.cyan('  # Validate with detailed output'));
    console.log('  $ email-validator validate user@gmail.com --verbose\n');
    console.log(chalk.cyan('  # Bulk validate from file'));
    console.log('  $ email-validator bulk emails.txt\n');
    console.log(chalk.cyan('  # Bulk validate and export to CSV'));
    console.log('  $ email-validator bulk emails.txt -o results.csv -f csv\n');
    console.log(chalk.cyan('  # Only show valid emails'));
    console.log('  $ email-validator bulk emails.txt --filter valid\n');
  });

program.parse();
```

### Step 4: Create Validate Command

Create `cli/src/commands/validate.ts`:

```typescript
import chalk from 'chalk';
import ora from 'ora';
import Table from 'cli-table3';
import { validateEmail } from '../../../src/lib/validators';
import type { ValidationResult } from '../../../src/types/email';

interface ValidateOptions {
  format: 'json' | 'table' | 'simple';
  verbose: boolean;
}

export async function validateCommand(email: string, options: ValidateOptions): Promise<void> {
  const spinner = ora(`Validating ${email}...`).start();

  try {
    const result = await validateEmail(email);
    spinner.stop();

    switch (options.format) {
      case 'json':
        console.log(JSON.stringify(result, null, 2));
        break;
      case 'table':
        printTableResult(result, options.verbose);
        break;
      case 'simple':
      default:
        printSimpleResult(result, options.verbose);
    }

    // Exit with appropriate code
    process.exit(result.isValid ? 0 : 1);
  } catch (error) {
    spinner.fail('Validation failed');
    console.error(chalk.red(error instanceof Error ? error.message : 'Unknown error'));
    process.exit(2);
  }
}

function printSimpleResult(result: ValidationResult, verbose: boolean): void {
  const status = result.isValid
    ? chalk.green('âœ“ VALID')
    : chalk.red('âœ— INVALID');

  console.log(`\n${result.email}: ${status}`);
  console.log(`Score: ${getScoreColor(result.score)}${result.score}/100${chalk.reset()}`);
  console.log(`Deliverability: ${result.deliverability}`);
  console.log(`Risk: ${getRiskColor(result.risk)}${result.risk}${chalk.reset()}`);

  if (verbose) {
    console.log('\n' + chalk.bold('Checks:'));
    printChecks(result);
  }
}

function printTableResult(result: ValidationResult, verbose: boolean): void {
  const table = new Table({
    head: [chalk.cyan('Property'), chalk.cyan('Value')],
  });

  table.push(
    ['Email', result.email],
    ['Valid', result.isValid ? chalk.green('Yes') : chalk.red('No')],
    ['Score', `${getScoreColor(result.score)}${result.score}/100${chalk.reset()}`],
    ['Deliverability', result.deliverability],
    ['Risk', `${getRiskColor(result.risk)}${result.risk}${chalk.reset()}`]
  );

  console.log(table.toString());

  if (verbose) {
    const checksTable = new Table({
      head: [chalk.cyan('Check'), chalk.cyan('Result'), chalk.cyan('Details')],
    });

    const { checks } = result;
    checksTable.push(
      ['Syntax', checks.syntax.valid ? chalk.green('âœ“') : chalk.red('âœ—'), checks.syntax.message],
      ['Domain', checks.domain.valid ? chalk.green('âœ“') : chalk.red('âœ—'), checks.domain.message],
      ['MX Records', checks.mx.valid ? chalk.green('âœ“') : chalk.red('âœ—'), checks.mx.message],
      ['Disposable', checks.disposable.isDisposable ? chalk.yellow('Yes') : chalk.green('No'), checks.disposable.message],
      ['Role-based', checks.roleBased.isRoleBased ? chalk.yellow('Yes') : chalk.green('No'), checks.roleBased.role || '-'],
      ['Free Provider', checks.freeProvider.isFree ? 'Yes' : 'No', checks.freeProvider.provider || '-'],
      ['Typo', checks.typo.hasTypo ? chalk.yellow('Yes') : chalk.green('No'), checks.typo.suggestion || '-']
    );

    console.log('\n' + chalk.bold('Validation Checks:'));
    console.log(checksTable.toString());
  }
}

function printChecks(result: ValidationResult): void {
  const { checks } = result;
  const checkIcon = (valid: boolean) => valid ? chalk.green('âœ“') : chalk.red('âœ—');

  console.log(`  ${checkIcon(checks.syntax.valid)} Syntax: ${checks.syntax.message}`);
  console.log(`  ${checkIcon(checks.domain.valid)} Domain: ${checks.domain.message}`);
  console.log(`  ${checkIcon(checks.mx.valid)} MX: ${checks.mx.message}`);
  console.log(`  ${checkIcon(!checks.disposable.isDisposable)} Disposable: ${checks.disposable.message}`);
  console.log(`  ${checkIcon(!checks.roleBased.isRoleBased)} Role-based: ${checks.roleBased.role || 'Not role-based'}`);
  console.log(`  â„¹ Free Provider: ${checks.freeProvider.provider || 'Not a free provider'}`);

  if (checks.typo.hasTypo) {
    console.log(chalk.yellow(`  âš  Typo detected: Did you mean ${checks.typo.suggestion}?`));
  }
}

function getScoreColor(score: number): string {
  if (score >= 80) return chalk.green.bold('');
  if (score >= 60) return chalk.yellow('');
  return chalk.red('');
}

function getRiskColor(risk: string): string {
  switch (risk) {
    case 'low': return chalk.green('');
    case 'medium': return chalk.yellow('');
    case 'high': return chalk.red('');
    default: return '';
  }
}
```

### Step 5: Create Bulk Command

Create `cli/src/commands/bulk.ts`:

```typescript
import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import cliProgress from 'cli-progress';
import Table from 'cli-table3';
import { validateEmail } from '../../../src/lib/validators';
import type { ValidationResult } from '../../../src/types/email';

interface BulkOptions {
  output?: string;
  format: 'json' | 'csv' | 'table';
  filter: 'all' | 'valid' | 'invalid' | 'risky';
  progress: boolean;
  concurrency: string;
}

export async function bulkCommand(file: string, options: BulkOptions): Promise<void> {
  // Read file
  const filePath = path.resolve(file);
  if (!fs.existsSync(filePath)) {
    console.error(chalk.red(`File not found: ${filePath}`));
    process.exit(1);
  }

  const content = fs.readFileSync(filePath, 'utf-8');
  const emails = parseEmails(content);

  if (emails.length === 0) {
    console.error(chalk.red('No valid emails found in file'));
    process.exit(1);
  }

  console.log(chalk.cyan(`\nFound ${emails.length} emails to validate\n`));

  // Validate with progress
  const results = await validateBulk(emails, options);

  // Filter results
  const filtered = filterResults(results, options.filter);

  // Output results
  outputResults(filtered, options);

  // Summary
  printSummary(results);
}

function parseEmails(content: string): string[] {
  const lines = content.split('\n');
  const emails: string[] = [];

  for (const line of lines) {
    // Handle CSV (take first column that looks like email)
    const parts = line.split(/[,;\t]/);
    for (const part of parts) {
      const trimmed = part.trim().replace(/^["']|["']$/g, '');
      if (trimmed.includes('@') && trimmed.length > 3) {
        emails.push(trimmed);
        break;
      }
    }
  }

  // Deduplicate
  return [...new Set(emails)];
}

async function validateBulk(
  emails: string[],
  options: BulkOptions
): Promise<ValidationResult[]> {
  const concurrency = parseInt(options.concurrency, 10) || 10;
  const results: ValidationResult[] = [];

  let progressBar: cliProgress.SingleBar | null = null;

  if (options.progress) {
    progressBar = new cliProgress.SingleBar({
      format: 'Validating |{bar}| {percentage}% | {value}/{total} emails | ETA: {eta}s',
      barCompleteChar: '\u2588',
      barIncompleteChar: '\u2591',
      hideCursor: true,
    });
    progressBar.start(emails.length, 0);
  }

  // Process in batches
  for (let i = 0; i < emails.length; i += concurrency) {
    const batch = emails.slice(i, i + concurrency);
    const batchResults = await Promise.all(
      batch.map(email => validateEmail(email).catch(err => ({
        email,
        isValid: false,
        score: 0,
        error: err.message,
      } as ValidationResult)))
    );

    results.push(...batchResults);

    if (progressBar) {
      progressBar.update(Math.min(i + concurrency, emails.length));
    }
  }

  if (progressBar) {
    progressBar.stop();
  }

  return results;
}

function filterResults(
  results: ValidationResult[],
  filter: string
): ValidationResult[] {
  switch (filter) {
    case 'valid':
      return results.filter(r => r.isValid);
    case 'invalid':
      return results.filter(r => !r.isValid);
    case 'risky':
      return results.filter(r => r.risk === 'high' || r.deliverability === 'risky');
    default:
      return results;
  }
}

function outputResults(results: ValidationResult[], options: BulkOptions): void {
  if (options.output) {
    // Write to file
    const outputPath = path.resolve(options.output);
    let content: string;

    if (options.format === 'csv') {
      content = toCSV(results);
    } else {
      content = JSON.stringify(results, null, 2);
    }

    fs.writeFileSync(outputPath, content);
    console.log(chalk.green(`\nResults saved to: ${outputPath}`));
  } else if (options.format === 'table') {
    // Print table to console
    printResultsTable(results);
  } else if (options.format === 'csv') {
    console.log(toCSV(results));
  } else {
    console.log(JSON.stringify(results, null, 2));
  }
}

function toCSV(results: ValidationResult[]): string {
  const headers = ['email', 'isValid', 'score', 'deliverability', 'risk', 'disposable', 'freeProvider'];
  const rows = results.map(r => [
    r.email,
    r.isValid,
    r.score,
    r.deliverability,
    r.risk,
    r.checks?.disposable?.isDisposable || false,
    r.checks?.freeProvider?.provider || ''
  ].join(','));

  return [headers.join(','), ...rows].join('\n');
}

function printResultsTable(results: ValidationResult[]): void {
  const table = new Table({
    head: [
      chalk.cyan('Email'),
      chalk.cyan('Valid'),
      chalk.cyan('Score'),
      chalk.cyan('Risk'),
      chalk.cyan('Deliverability')
    ],
    colWidths: [40, 8, 8, 10, 15],
  });

  for (const result of results.slice(0, 50)) {
    table.push([
      result.email.substring(0, 38),
      result.isValid ? chalk.green('âœ“') : chalk.red('âœ—'),
      result.score.toString(),
      getRiskColor(result.risk) + result.risk + chalk.reset(),
      result.deliverability
    ]);
  }

  console.log(table.toString());

  if (results.length > 50) {
    console.log(chalk.yellow(`\n... and ${results.length - 50} more results`));
  }
}

function printSummary(results: ValidationResult[]): void {
  const valid = results.filter(r => r.isValid).length;
  const invalid = results.length - valid;
  const avgScore = results.reduce((sum, r) => sum + r.score, 0) / results.length;

  console.log(chalk.bold('\nðŸ“Š Summary:'));
  console.log(`  Total: ${results.length}`);
  console.log(`  ${chalk.green('Valid')}: ${valid} (${((valid / results.length) * 100).toFixed(1)}%)`);
  console.log(`  ${chalk.red('Invalid')}: ${invalid} (${((invalid / results.length) * 100).toFixed(1)}%)`);
  console.log(`  Average Score: ${avgScore.toFixed(1)}/100`);
}

function getRiskColor(risk: string): string {
  switch (risk) {
    case 'low': return chalk.green('');
    case 'medium': return chalk.yellow('');
    case 'high': return chalk.red('');
    default: return '';
  }
}
```

### Step 6: Create Executable

Create `cli/bin/email-validator`:

```bash
#!/usr/bin/env node
require('../dist/index.js');
```

### Step 7: Create tsconfig.json for CLI

Create `cli/tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### Step 8: Write Tests

Create `cli/src/__tests__/cli.test.ts`:

```typescript
import { execSync } from 'child_process';
import path from 'path';
import fs from 'fs';

describe('CLI Tool', () => {
  const cliPath = path.join(__dirname, '../../dist/index.js');

  beforeAll(() => {
    // Build CLI
    execSync('npm run build', { cwd: path.join(__dirname, '../..') });
  });

  describe('validate command', () => {
    test('validates valid email', () => {
      const result = execSync(`node ${cliPath} validate test@gmail.com -f json`);
      const output = JSON.parse(result.toString());
      expect(output.email).toBe('test@gmail.com');
      expect(output.isValid).toBe(true);
    });

    test('detects invalid email', () => {
      try {
        execSync(`node ${cliPath} validate invalid-email -f json`);
      } catch (error: any) {
        const output = JSON.parse(error.stdout.toString());
        expect(output.isValid).toBe(false);
      }
    });

    test('supports table format', () => {
      const result = execSync(`node ${cliPath} validate test@gmail.com -f table`);
      expect(result.toString()).toContain('Email');
      expect(result.toString()).toContain('test@gmail.com');
    });
  });

  describe('bulk command', () => {
    const testFile = path.join(__dirname, 'test-emails.txt');

    beforeAll(() => {
      fs.writeFileSync(testFile, 'test1@gmail.com\ntest2@yahoo.com\ninvalid-email');
    });

    afterAll(() => {
      fs.unlinkSync(testFile);
    });

    test('validates emails from file', () => {
      const result = execSync(`node ${cliPath} bulk ${testFile} -f json --no-progress`);
      const output = JSON.parse(result.toString());
      expect(Array.isArray(output)).toBe(true);
      expect(output.length).toBe(3);
    });

    test('filters valid emails', () => {
      const result = execSync(`node ${cliPath} bulk ${testFile} -f json --filter valid --no-progress`);
      const output = JSON.parse(result.toString());
      output.forEach((r: any) => expect(r.isValid).toBe(true));
    });
  });
});
```

---

## Completion Checklist

```
[x] CLI package structure created
[x] package.json with correct metadata
[x] Main entry point (index.ts)
[x] Validate command implemented
[x] Bulk command implemented
[x] Progress indicators working
[x] JSON output format
[x] CSV output format
[x] Table output format
[x] File output option
[x] Filter options working
[x] Executable script created
[x] TypeScript configuration
[x] Tests written and passing (51 tests)
[x] Documentation (README.md)
[x] All existing project tests pass (866 tests)
[x] Changes committed and pushed
```

---

## Next Milestone

After completing this milestone, proceed to:
`plans/milestones/6.3-postman-collection.md`
