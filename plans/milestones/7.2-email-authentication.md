# Milestone 7.2: Email Authentication (DMARC/SPF/DKIM)

> **Phase:** 7 - Advanced Validation
> **Status:** COMPLETED
> **Priority:** MEDIUM
> **Complexity:** Medium
> **Estimated Time:** 4-5 hours

---

## Prompt for Claude Code

```
You are working on the Email Validator project. Your task is to implement email authentication checks (DMARC, SPF, DKIM).

IMPORTANT INSTRUCTIONS:
1. Read this entire file before starting
2. Follow the implementation steps in order
3. Write comprehensive tests
4. Update the checklist as you complete each task
5. Commit with message: "feat: add DMARC/SPF/DKIM email authentication checks"
6. Push the changes

PROJECT CONTEXT:
- Existing validators are in src/lib/validators/
- DNS utilities can be added to src/lib/dns/
- Types in src/types/email.ts
- This enhances email security assessment
```

---

## Objective

Implement email authentication record checks to assess domain email security:
- SPF (Sender Policy Framework) record parsing
- DMARC (Domain-based Message Authentication) record parsing
- DKIM selector detection (common selectors)
- Calculate authentication score
- Display results in UI

---

## Implementation Steps

### Step 1: Create Authentication Types

Create `src/lib/auth/types.ts`:

```typescript
export interface SPFRecord {
  raw: string;
  version: string;
  mechanisms: SPFMechanism[];
  modifiers: SPFModifier[];
  valid: boolean;
  errors: string[];
}

export interface SPFMechanism {
  qualifier: '+' | '-' | '~' | '?';
  type: 'all' | 'include' | 'a' | 'mx' | 'ptr' | 'ip4' | 'ip6' | 'exists';
  value?: string;
}

export interface SPFModifier {
  type: 'redirect' | 'exp';
  value: string;
}

export interface DMARCRecord {
  raw: string;
  version: string;
  policy: 'none' | 'quarantine' | 'reject';
  subdomainPolicy?: 'none' | 'quarantine' | 'reject';
  percentage?: number;
  rua?: string[];  // Aggregate report URIs
  ruf?: string[];  // Forensic report URIs
  adkim?: 'r' | 's';  // DKIM alignment mode
  aspf?: 'r' | 's';   // SPF alignment mode
  valid: boolean;
  errors: string[];
}

export interface DKIMRecord {
  selector: string;
  raw: string;
  version?: string;
  keyType?: string;
  publicKey?: string;
  valid: boolean;
  errors: string[];
}

export interface AuthenticationResult {
  spf: SPFCheckResult;
  dmarc: DMARCCheckResult;
  dkim: DKIMCheckResult;
  score: number;  // 0-100
  summary: string;
}

export interface SPFCheckResult {
  exists: boolean;
  record?: SPFRecord;
  strength: 'strong' | 'moderate' | 'weak' | 'none';
  message: string;
}

export interface DMARCCheckResult {
  exists: boolean;
  record?: DMARCRecord;
  strength: 'strong' | 'moderate' | 'weak' | 'none';
  message: string;
}

export interface DKIMCheckResult {
  found: boolean;
  records: DKIMRecord[];
  selectorsChecked: string[];
  message: string;
}
```

### Step 2: Create SPF Parser

Create `src/lib/auth/spf.ts`:

```typescript
import { resolveTxt } from 'dns/promises';
import { SPFRecord, SPFMechanism, SPFModifier, SPFCheckResult } from './types';

const SPF_QUALIFIERS = ['+', '-', '~', '?'] as const;
const SPF_MECHANISMS = ['all', 'include', 'a', 'mx', 'ptr', 'ip4', 'ip6', 'exists'] as const;

export async function checkSPF(domain: string): Promise<SPFCheckResult> {
  try {
    const records = await resolveTxt(domain);
    const spfRecord = records.flat().find(r => r.startsWith('v=spf1'));

    if (!spfRecord) {
      return {
        exists: false,
        strength: 'none',
        message: 'No SPF record found',
      };
    }

    const parsed = parseSPF(spfRecord);
    const strength = evaluateSPFStrength(parsed);

    return {
      exists: true,
      record: parsed,
      strength,
      message: getSPFMessage(strength, parsed),
    };
  } catch (error) {
    return {
      exists: false,
      strength: 'none',
      message: error instanceof Error ? error.message : 'Failed to check SPF',
    };
  }
}

export function parseSPF(record: string): SPFRecord {
  const errors: string[] = [];
  const mechanisms: SPFMechanism[] = [];
  const modifiers: SPFModifier[] = [];

  const parts = record.trim().split(/\s+/);
  const version = parts[0];

  if (version !== 'v=spf1') {
    errors.push('Invalid SPF version');
  }

  for (let i = 1; i < parts.length; i++) {
    const part = parts[i];

    // Check for modifiers (redirect=, exp=)
    if (part.includes('=')) {
      const [type, value] = part.split('=');
      if (type === 'redirect' || type === 'exp') {
        modifiers.push({ type, value });
      }
      continue;
    }

    // Parse mechanism
    let qualifier: SPFMechanism['qualifier'] = '+';
    let mechanismStr = part;

    if (SPF_QUALIFIERS.includes(part[0] as any)) {
      qualifier = part[0] as SPFMechanism['qualifier'];
      mechanismStr = part.slice(1);
    }

    // Extract mechanism type and value
    const colonIndex = mechanismStr.indexOf(':');
    const slashIndex = mechanismStr.indexOf('/');

    let type: string;
    let value: string | undefined;

    if (colonIndex !== -1) {
      type = mechanismStr.slice(0, colonIndex);
      value = mechanismStr.slice(colonIndex + 1);
    } else if (slashIndex !== -1) {
      type = mechanismStr.slice(0, slashIndex);
      value = mechanismStr.slice(slashIndex);
    } else {
      type = mechanismStr;
    }

    if (SPF_MECHANISMS.includes(type as any)) {
      mechanisms.push({
        qualifier,
        type: type as SPFMechanism['type'],
        value,
      });
    } else {
      errors.push(`Unknown mechanism: ${type}`);
    }
  }

  return {
    raw: record,
    version,
    mechanisms,
    modifiers,
    valid: errors.length === 0,
    errors,
  };
}

function evaluateSPFStrength(record: SPFRecord): SPFCheckResult['strength'] {
  if (!record.valid) return 'weak';

  const allMechanism = record.mechanisms.find(m => m.type === 'all');

  if (!allMechanism) return 'weak';

  // -all is strong (hard fail)
  if (allMechanism.qualifier === '-') {
    return 'strong';
  }

  // ~all is moderate (soft fail)
  if (allMechanism.qualifier === '~') {
    return 'moderate';
  }

  // ?all or +all is weak
  return 'weak';
}

function getSPFMessage(strength: SPFCheckResult['strength'], record: SPFRecord): string {
  switch (strength) {
    case 'strong':
      return 'SPF configured with hard fail (-all)';
    case 'moderate':
      return 'SPF configured with soft fail (~all)';
    case 'weak':
      return 'SPF configured but with weak policy';
    default:
      return 'No SPF record found';
  }
}
```

### Step 3: Create DMARC Parser

Create `src/lib/auth/dmarc.ts`:

```typescript
import { resolveTxt } from 'dns/promises';
import { DMARCRecord, DMARCCheckResult } from './types';

export async function checkDMARC(domain: string): Promise<DMARCCheckResult> {
  try {
    const dmarcDomain = `_dmarc.${domain}`;
    const records = await resolveTxt(dmarcDomain);
    const dmarcRecord = records.flat().find(r => r.startsWith('v=DMARC1'));

    if (!dmarcRecord) {
      return {
        exists: false,
        strength: 'none',
        message: 'No DMARC record found',
      };
    }

    const parsed = parseDMARC(dmarcRecord);
    const strength = evaluateDMARCStrength(parsed);

    return {
      exists: true,
      record: parsed,
      strength,
      message: getDMARCMessage(strength, parsed),
    };
  } catch (error) {
    return {
      exists: false,
      strength: 'none',
      message: error instanceof Error ? error.message : 'Failed to check DMARC',
    };
  }
}

export function parseDMARC(record: string): DMARCRecord {
  const errors: string[] = [];
  const result: DMARCRecord = {
    raw: record,
    version: '',
    policy: 'none',
    valid: true,
    errors: [],
  };

  const parts = record.split(';').map(p => p.trim()).filter(Boolean);

  for (const part of parts) {
    const [key, ...valueParts] = part.split('=');
    const value = valueParts.join('=').trim();

    switch (key.trim().toLowerCase()) {
      case 'v':
        result.version = value;
        if (value !== 'DMARC1') {
          errors.push('Invalid DMARC version');
        }
        break;
      case 'p':
        if (['none', 'quarantine', 'reject'].includes(value)) {
          result.policy = value as DMARCRecord['policy'];
        } else {
          errors.push(`Invalid policy: ${value}`);
        }
        break;
      case 'sp':
        if (['none', 'quarantine', 'reject'].includes(value)) {
          result.subdomainPolicy = value as DMARCRecord['subdomainPolicy'];
        }
        break;
      case 'pct':
        result.percentage = parseInt(value, 10);
        break;
      case 'rua':
        result.rua = value.split(',').map(u => u.trim());
        break;
      case 'ruf':
        result.ruf = value.split(',').map(u => u.trim());
        break;
      case 'adkim':
        if (['r', 's'].includes(value)) {
          result.adkim = value as 'r' | 's';
        }
        break;
      case 'aspf':
        if (['r', 's'].includes(value)) {
          result.aspf = value as 'r' | 's';
        }
        break;
    }
  }

  result.errors = errors;
  result.valid = errors.length === 0;

  return result;
}

function evaluateDMARCStrength(record: DMARCRecord): DMARCCheckResult['strength'] {
  if (!record.valid) return 'weak';

  switch (record.policy) {
    case 'reject':
      return 'strong';
    case 'quarantine':
      return 'moderate';
    case 'none':
      // 'none' with reporting is at least monitoring
      if (record.rua || record.ruf) {
        return 'weak';
      }
      return 'none';
    default:
      return 'none';
  }
}

function getDMARCMessage(strength: DMARCCheckResult['strength'], record: DMARCRecord): string {
  switch (strength) {
    case 'strong':
      return `DMARC policy: reject (${record.percentage ?? 100}%)`;
    case 'moderate':
      return `DMARC policy: quarantine (${record.percentage ?? 100}%)`;
    case 'weak':
      return 'DMARC policy: none (monitoring only)';
    default:
      return 'No DMARC policy configured';
  }
}
```

### Step 4: Create DKIM Checker

Create `src/lib/auth/dkim.ts`:

```typescript
import { resolveTxt } from 'dns/promises';
import { DKIMRecord, DKIMCheckResult } from './types';

// Common DKIM selectors used by popular email providers
const COMMON_SELECTORS = [
  'default',
  'selector1',  // Microsoft 365
  'selector2',  // Microsoft 365
  'google',     // Google Workspace
  's1',
  's2',
  'k1',
  'dkim',
  'mail',
  'email',
  'smtp',
  'mx',
];

export async function checkDKIM(domain: string): Promise<DKIMCheckResult> {
  const records: DKIMRecord[] = [];
  const selectorsChecked: string[] = [];

  for (const selector of COMMON_SELECTORS) {
    selectorsChecked.push(selector);

    try {
      const dkimDomain = `${selector}._domainkey.${domain}`;
      const txtRecords = await resolveTxt(dkimDomain);
      const dkimRecord = txtRecords.flat().join('');

      if (dkimRecord && dkimRecord.includes('p=')) {
        const parsed = parseDKIM(selector, dkimRecord);
        records.push(parsed);
      }
    } catch {
      // Selector not found, continue to next
      continue;
    }
  }

  return {
    found: records.length > 0,
    records,
    selectorsChecked,
    message: records.length > 0
      ? `Found ${records.length} DKIM record(s)`
      : 'No DKIM records found for common selectors',
  };
}

export function parseDKIM(selector: string, record: string): DKIMRecord {
  const errors: string[] = [];
  const result: DKIMRecord = {
    selector,
    raw: record,
    valid: true,
    errors: [],
  };

  const parts = record.split(';').map(p => p.trim()).filter(Boolean);

  for (const part of parts) {
    const [key, ...valueParts] = part.split('=');
    const value = valueParts.join('=').trim();

    switch (key.trim().toLowerCase()) {
      case 'v':
        result.version = value;
        break;
      case 'k':
        result.keyType = value;
        break;
      case 'p':
        result.publicKey = value;
        if (!value) {
          errors.push('Empty public key (revoked)');
        }
        break;
    }
  }

  result.errors = errors;
  result.valid = errors.length === 0 && !!result.publicKey;

  return result;
}
```

### Step 5: Create Authentication Index

Create `src/lib/auth/index.ts`:

```typescript
import { checkSPF } from './spf';
import { checkDMARC } from './dmarc';
import { checkDKIM } from './dkim';
import { AuthenticationResult } from './types';
import { LRUCache } from '../cache';

// Cache authentication results
const authCache = new LRUCache<AuthenticationResult>({
  maxSize: 500,
  ttlMs: 10 * 60 * 1000, // 10 minutes
  name: 'auth',
});

export async function checkEmailAuthentication(domain: string): Promise<AuthenticationResult> {
  // Check cache
  const cached = authCache.get(domain);
  if (cached) {
    return cached;
  }

  // Run all checks in parallel
  const [spf, dmarc, dkim] = await Promise.all([
    checkSPF(domain),
    checkDMARC(domain),
    checkDKIM(domain),
  ]);

  // Calculate overall score
  const score = calculateAuthScore(spf, dmarc, dkim);
  const summary = generateSummary(spf, dmarc, dkim, score);

  const result: AuthenticationResult = {
    spf,
    dmarc,
    dkim,
    score,
    summary,
  };

  // Cache the result
  authCache.set(domain, result);

  return result;
}

function calculateAuthScore(
  spf: AuthenticationResult['spf'],
  dmarc: AuthenticationResult['dmarc'],
  dkim: AuthenticationResult['dkim']
): number {
  let score = 0;

  // SPF scoring (max 35 points)
  switch (spf.strength) {
    case 'strong': score += 35; break;
    case 'moderate': score += 25; break;
    case 'weak': score += 10; break;
  }

  // DMARC scoring (max 35 points)
  switch (dmarc.strength) {
    case 'strong': score += 35; break;
    case 'moderate': score += 25; break;
    case 'weak': score += 10; break;
  }

  // DKIM scoring (max 30 points)
  if (dkim.found) {
    const validRecords = dkim.records.filter(r => r.valid).length;
    if (validRecords > 0) {
      score += Math.min(30, validRecords * 15);
    }
  }

  return Math.min(100, score);
}

function generateSummary(
  spf: AuthenticationResult['spf'],
  dmarc: AuthenticationResult['dmarc'],
  dkim: AuthenticationResult['dkim'],
  score: number
): string {
  if (score >= 80) {
    return 'Excellent email authentication configuration';
  } else if (score >= 60) {
    return 'Good email authentication with room for improvement';
  } else if (score >= 40) {
    return 'Basic email authentication configured';
  } else if (score > 0) {
    return 'Weak email authentication setup';
  } else {
    return 'No email authentication configured';
  }
}

export { checkSPF } from './spf';
export { checkDMARC } from './dmarc';
export { checkDKIM } from './dkim';
export * from './types';
```

### Step 6: Create Authentication Validator

Create `src/lib/validators/authentication.ts`:

```typescript
import { checkEmailAuthentication, AuthenticationResult } from '../auth';

export interface AuthCheckResult {
  checked: boolean;
  authentication?: AuthenticationResult;
  message: string;
}

export async function checkAuthentication(
  domain: string,
  options: { enabled?: boolean } = {}
): Promise<AuthCheckResult> {
  const { enabled = true } = options;

  if (!enabled) {
    return {
      checked: false,
      message: 'Authentication check disabled',
    };
  }

  try {
    const authentication = await checkEmailAuthentication(domain);

    return {
      checked: true,
      authentication,
      message: authentication.summary,
    };
  } catch (error) {
    return {
      checked: false,
      message: error instanceof Error ? error.message : 'Authentication check failed',
    };
  }
}
```

### Step 7: Update Main Validator

Update `src/lib/validators/index.ts`:

```typescript
// Add to imports
import { checkAuthentication, AuthCheckResult } from './authentication';

// Add to ValidationResult type
interface ValidationResult {
  // ... existing fields
  checks: {
    // ... existing checks
    authentication?: AuthCheckResult;
  };
}

// Add to validateEmail function
export async function validateEmail(
  email: string,
  options: {
    authCheck?: boolean;
    // ... existing options
  } = {}
): Promise<ValidationResult> {
  // ... existing validation

  // Authentication check (optional)
  let authResult: AuthCheckResult | undefined;
  if (options.authCheck && domain) {
    authResult = await checkAuthentication(domain, { enabled: true });

    // Adjust score based on authentication
    if (authResult.checked && authResult.authentication) {
      const authScore = authResult.authentication.score;
      // Bonus for good authentication (up to +5 points)
      if (authScore >= 80) {
        score = Math.min(100, score + 5);
      }
      // Slight penalty for no authentication (-5 points)
      if (authScore === 0) {
        score = Math.max(0, score - 5);
      }
    }
  }

  return {
    // ... existing return
    checks: {
      // ... existing checks
      authentication: authResult,
    },
  };
}
```

### Step 8: Update Types

Update `src/types/email.ts`:

```typescript
export interface ValidationChecks {
  // ... existing checks
  authentication?: {
    checked: boolean;
    authentication?: {
      spf: {
        exists: boolean;
        strength: 'strong' | 'moderate' | 'weak' | 'none';
        message: string;
      };
      dmarc: {
        exists: boolean;
        strength: 'strong' | 'moderate' | 'weak' | 'none';
        message: string;
      };
      dkim: {
        found: boolean;
        recordCount: number;
        message: string;
      };
      score: number;
      summary: string;
    };
    message: string;
  };
}
```

### Step 9: Update UI

Update `src/components/email/ValidationResult.tsx`:

```typescript
// Add authentication section
{result.checks.authentication?.checked && result.checks.authentication.authentication && (
  <div className="border-t pt-4 mt-4">
    <h4 className="font-semibold flex items-center gap-2">
      <Shield className="h-4 w-4" />
      Email Authentication
    </h4>
    <div className="mt-2 space-y-2 text-sm">
      {/* Authentication Score */}
      <div className="flex justify-between items-center">
        <span>Authentication Score:</span>
        <span className={`font-medium ${
          result.checks.authentication.authentication.score >= 80 ? 'text-green-600' :
          result.checks.authentication.authentication.score >= 60 ? 'text-yellow-600' :
          'text-red-600'
        }`}>
          {result.checks.authentication.authentication.score}/100
        </span>
      </div>

      {/* SPF Status */}
      <div className="flex justify-between items-center">
        <span className="flex items-center gap-1">
          SPF:
        </span>
        <span className={getStrengthColor(result.checks.authentication.authentication.spf.strength)}>
          {result.checks.authentication.authentication.spf.exists
            ? result.checks.authentication.authentication.spf.strength.toUpperCase()
            : 'NOT FOUND'}
        </span>
      </div>

      {/* DMARC Status */}
      <div className="flex justify-between items-center">
        <span>DMARC:</span>
        <span className={getStrengthColor(result.checks.authentication.authentication.dmarc.strength)}>
          {result.checks.authentication.authentication.dmarc.exists
            ? result.checks.authentication.authentication.dmarc.strength.toUpperCase()
            : 'NOT FOUND'}
        </span>
      </div>

      {/* DKIM Status */}
      <div className="flex justify-between items-center">
        <span>DKIM:</span>
        <span className={result.checks.authentication.authentication.dkim.found ? 'text-green-600' : 'text-yellow-600'}>
          {result.checks.authentication.authentication.dkim.found
            ? `FOUND (${result.checks.authentication.authentication.dkim.recordCount} record(s))`
            : 'NOT FOUND'}
        </span>
      </div>

      {/* Summary */}
      <p className="text-muted-foreground mt-2">
        {result.checks.authentication.authentication.summary}
      </p>
    </div>
  </div>
)}

// Helper function
function getStrengthColor(strength: string): string {
  switch (strength) {
    case 'strong': return 'text-green-600';
    case 'moderate': return 'text-yellow-600';
    case 'weak': return 'text-orange-600';
    default: return 'text-red-600';
  }
}
```

### Step 10: Write Tests

Create `src/__tests__/lib/auth/auth.test.ts`:

```typescript
import { parseSPF } from '@/lib/auth/spf';
import { parseDMARC } from '@/lib/auth/dmarc';
import { parseDKIM } from '@/lib/auth/dkim';

describe('Email Authentication', () => {
  describe('SPF Parser', () => {
    test('parses valid SPF record with -all', () => {
      const record = 'v=spf1 include:_spf.google.com ~all';
      const result = parseSPF(record);

      expect(result.valid).toBe(true);
      expect(result.version).toBe('v=spf1');
      expect(result.mechanisms).toHaveLength(2);
      expect(result.mechanisms[0].type).toBe('include');
      expect(result.mechanisms[1].type).toBe('all');
      expect(result.mechanisms[1].qualifier).toBe('~');
    });

    test('parses SPF with ip4 mechanism', () => {
      const record = 'v=spf1 ip4:192.168.1.0/24 -all';
      const result = parseSPF(record);

      expect(result.valid).toBe(true);
      expect(result.mechanisms[0].type).toBe('ip4');
      expect(result.mechanisms[0].value).toBe('192.168.1.0/24');
    });

    test('parses SPF with redirect modifier', () => {
      const record = 'v=spf1 redirect=_spf.example.com';
      const result = parseSPF(record);

      expect(result.modifiers).toHaveLength(1);
      expect(result.modifiers[0].type).toBe('redirect');
      expect(result.modifiers[0].value).toBe('_spf.example.com');
    });
  });

  describe('DMARC Parser', () => {
    test('parses valid DMARC record', () => {
      const record = 'v=DMARC1; p=reject; rua=mailto:dmarc@example.com';
      const result = parseDMARC(record);

      expect(result.valid).toBe(true);
      expect(result.version).toBe('DMARC1');
      expect(result.policy).toBe('reject');
      expect(result.rua).toContain('mailto:dmarc@example.com');
    });

    test('parses DMARC with subdomain policy', () => {
      const record = 'v=DMARC1; p=quarantine; sp=reject; pct=50';
      const result = parseDMARC(record);

      expect(result.policy).toBe('quarantine');
      expect(result.subdomainPolicy).toBe('reject');
      expect(result.percentage).toBe(50);
    });

    test('parses DMARC with alignment modes', () => {
      const record = 'v=DMARC1; p=none; adkim=s; aspf=r';
      const result = parseDMARC(record);

      expect(result.adkim).toBe('s');
      expect(result.aspf).toBe('r');
    });
  });

  describe('DKIM Parser', () => {
    test('parses valid DKIM record', () => {
      const record = 'v=DKIM1; k=rsa; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GN...';
      const result = parseDKIM('selector1', record);

      expect(result.valid).toBe(true);
      expect(result.selector).toBe('selector1');
      expect(result.version).toBe('DKIM1');
      expect(result.keyType).toBe('rsa');
      expect(result.publicKey).toBeTruthy();
    });

    test('detects revoked DKIM record', () => {
      const record = 'v=DKIM1; p=';
      const result = parseDKIM('default', record);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Empty public key (revoked)');
    });
  });
});
```

---

## Completion Checklist

```
[x] Authentication types defined
[x] SPF parser implemented
[x] SPF strength evaluation
[x] DMARC parser implemented
[x] DMARC strength evaluation
[x] DKIM checker implemented
[x] Common selector detection
[x] Authentication score calculation
[x] Caching implemented
[x] Validator created
[x] Main validator updated
[x] Types updated
[x] UI updated to show results
[x] Tests written and passing
[x] All existing tests pass
[ ] Changes committed and pushed
```

---

## Next Milestone

After completing this milestone, proceed to:
`plans/milestones/7.3-domain-reputation.md`
