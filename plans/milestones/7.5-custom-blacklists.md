# Milestone 7.5: Custom Blacklists

> **Phase:** 7 - Advanced Validation
> **Status:** NOT STARTED
> **Priority:** LOW
> **Complexity:** Low
> **Estimated Time:** 2-3 hours

---

## Prompt for Claude Code

```
You are working on the Email Validator project. Your task is to implement custom blacklist management.

IMPORTANT INSTRUCTIONS:
1. Read this entire file before starting
2. Follow the implementation steps in order
3. Write comprehensive tests
4. Update the checklist as you complete each task
5. Commit with message: "feat: add custom blacklist management"
6. Push the changes

PROJECT CONTEXT:
- Existing validators are in src/lib/validators/
- State management with Zustand
- localStorage for persistence
- Types in src/types/email.ts
```

---

## Objective

Implement custom blacklist management allowing users to:
- Create and manage domain/email blacklists
- Import/export blacklists
- Pattern matching (wildcards)
- Persist blacklists in localStorage
- Check emails against custom blacklists

---

## Implementation Steps

### Step 1: Create Blacklist Types

Create `src/lib/blacklist/types.ts`:

```typescript
export interface BlacklistEntry {
  id: string;
  pattern: string;
  type: 'domain' | 'email' | 'pattern';
  reason?: string;
  createdAt: Date;
  isActive: boolean;
}

export interface Blacklist {
  id: string;
  name: string;
  description?: string;
  entries: BlacklistEntry[];
  createdAt: Date;
  updatedAt: Date;
}

export interface BlacklistCheckResult {
  isBlacklisted: boolean;
  matchedEntries: BlacklistEntry[];
  message: string;
}

export interface BlacklistExport {
  version: string;
  exportedAt: string;
  blacklists: Blacklist[];
}
```

### Step 2: Create Blacklist Store

Create `src/stores/blacklist-store.ts`:

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { Blacklist, BlacklistEntry } from '@/lib/blacklist/types';

interface BlacklistState {
  blacklists: Blacklist[];
  activeBlacklistId: string | null;

  // Blacklist CRUD
  createBlacklist: (name: string, description?: string) => Blacklist;
  updateBlacklist: (id: string, updates: Partial<Blacklist>) => void;
  deleteBlacklist: (id: string) => void;
  getBlacklist: (id: string) => Blacklist | undefined;

  // Entry CRUD
  addEntry: (blacklistId: string, entry: Omit<BlacklistEntry, 'id' | 'createdAt'>) => void;
  updateEntry: (blacklistId: string, entryId: string, updates: Partial<BlacklistEntry>) => void;
  removeEntry: (blacklistId: string, entryId: string) => void;
  toggleEntry: (blacklistId: string, entryId: string) => void;

  // Bulk operations
  importEntries: (blacklistId: string, patterns: string[], type: BlacklistEntry['type']) => void;
  clearEntries: (blacklistId: string) => void;

  // Export/Import
  exportBlacklists: () => string;
  importBlacklists: (json: string) => { success: boolean; message: string };

  // Active blacklist
  setActiveBlacklist: (id: string | null) => void;
}

const generateId = () => Math.random().toString(36).substring(2, 15);

export const useBlacklistStore = create<BlacklistState>()(
  persist(
    (set, get) => ({
      blacklists: [],
      activeBlacklistId: null,

      createBlacklist: (name, description) => {
        const newBlacklist: Blacklist = {
          id: generateId(),
          name,
          description,
          entries: [],
          createdAt: new Date(),
          updatedAt: new Date(),
        };

        set((state) => ({
          blacklists: [...state.blacklists, newBlacklist],
        }));

        return newBlacklist;
      },

      updateBlacklist: (id, updates) => {
        set((state) => ({
          blacklists: state.blacklists.map((bl) =>
            bl.id === id ? { ...bl, ...updates, updatedAt: new Date() } : bl
          ),
        }));
      },

      deleteBlacklist: (id) => {
        set((state) => ({
          blacklists: state.blacklists.filter((bl) => bl.id !== id),
          activeBlacklistId:
            state.activeBlacklistId === id ? null : state.activeBlacklistId,
        }));
      },

      getBlacklist: (id) => {
        return get().blacklists.find((bl) => bl.id === id);
      },

      addEntry: (blacklistId, entry) => {
        const newEntry: BlacklistEntry = {
          ...entry,
          id: generateId(),
          createdAt: new Date(),
        };

        set((state) => ({
          blacklists: state.blacklists.map((bl) =>
            bl.id === blacklistId
              ? {
                  ...bl,
                  entries: [...bl.entries, newEntry],
                  updatedAt: new Date(),
                }
              : bl
          ),
        }));
      },

      updateEntry: (blacklistId, entryId, updates) => {
        set((state) => ({
          blacklists: state.blacklists.map((bl) =>
            bl.id === blacklistId
              ? {
                  ...bl,
                  entries: bl.entries.map((e) =>
                    e.id === entryId ? { ...e, ...updates } : e
                  ),
                  updatedAt: new Date(),
                }
              : bl
          ),
        }));
      },

      removeEntry: (blacklistId, entryId) => {
        set((state) => ({
          blacklists: state.blacklists.map((bl) =>
            bl.id === blacklistId
              ? {
                  ...bl,
                  entries: bl.entries.filter((e) => e.id !== entryId),
                  updatedAt: new Date(),
                }
              : bl
          ),
        }));
      },

      toggleEntry: (blacklistId, entryId) => {
        set((state) => ({
          blacklists: state.blacklists.map((bl) =>
            bl.id === blacklistId
              ? {
                  ...bl,
                  entries: bl.entries.map((e) =>
                    e.id === entryId ? { ...e, isActive: !e.isActive } : e
                  ),
                  updatedAt: new Date(),
                }
              : bl
          ),
        }));
      },

      importEntries: (blacklistId, patterns, type) => {
        const newEntries: BlacklistEntry[] = patterns
          .filter((p) => p.trim())
          .map((pattern) => ({
            id: generateId(),
            pattern: pattern.trim().toLowerCase(),
            type,
            createdAt: new Date(),
            isActive: true,
          }));

        set((state) => ({
          blacklists: state.blacklists.map((bl) =>
            bl.id === blacklistId
              ? {
                  ...bl,
                  entries: [...bl.entries, ...newEntries],
                  updatedAt: new Date(),
                }
              : bl
          ),
        }));
      },

      clearEntries: (blacklistId) => {
        set((state) => ({
          blacklists: state.blacklists.map((bl) =>
            bl.id === blacklistId
              ? { ...bl, entries: [], updatedAt: new Date() }
              : bl
          ),
        }));
      },

      exportBlacklists: () => {
        const exportData = {
          version: '1.0',
          exportedAt: new Date().toISOString(),
          blacklists: get().blacklists,
        };
        return JSON.stringify(exportData, null, 2);
      },

      importBlacklists: (json) => {
        try {
          const data = JSON.parse(json);

          if (!data.blacklists || !Array.isArray(data.blacklists)) {
            return { success: false, message: 'Invalid format: missing blacklists array' };
          }

          // Assign new IDs to avoid conflicts
          const importedBlacklists = data.blacklists.map((bl: Blacklist) => ({
            ...bl,
            id: generateId(),
            entries: bl.entries.map((e) => ({
              ...e,
              id: generateId(),
              createdAt: new Date(e.createdAt),
            })),
            createdAt: new Date(bl.createdAt),
            updatedAt: new Date(),
          }));

          set((state) => ({
            blacklists: [...state.blacklists, ...importedBlacklists],
          }));

          return {
            success: true,
            message: `Imported ${importedBlacklists.length} blacklist(s)`,
          };
        } catch (error) {
          return { success: false, message: 'Invalid JSON format' };
        }
      },

      setActiveBlacklist: (id) => {
        set({ activeBlacklistId: id });
      },
    }),
    {
      name: 'email-validator-blacklists',
      partialize: (state) => ({
        blacklists: state.blacklists,
        activeBlacklistId: state.activeBlacklistId,
      }),
    }
  )
);
```

### Step 3: Create Blacklist Checker

Create `src/lib/blacklist/checker.ts`:

```typescript
import { BlacklistEntry, BlacklistCheckResult, Blacklist } from './types';

/**
 * Check if an email matches any blacklist entries
 */
export function checkAgainstBlacklist(
  email: string,
  blacklists: Blacklist[]
): BlacklistCheckResult {
  const normalizedEmail = email.toLowerCase().trim();
  const domain = normalizedEmail.split('@')[1];
  const matchedEntries: BlacklistEntry[] = [];

  for (const blacklist of blacklists) {
    for (const entry of blacklist.entries) {
      if (!entry.isActive) continue;

      const matches = matchesEntry(normalizedEmail, domain, entry);
      if (matches) {
        matchedEntries.push(entry);
      }
    }
  }

  return {
    isBlacklisted: matchedEntries.length > 0,
    matchedEntries,
    message:
      matchedEntries.length > 0
        ? `Matched ${matchedEntries.length} blacklist rule(s)`
        : 'Not blacklisted',
  };
}

/**
 * Check if email/domain matches a blacklist entry
 */
function matchesEntry(
  email: string,
  domain: string,
  entry: BlacklistEntry
): boolean {
  const pattern = entry.pattern.toLowerCase();

  switch (entry.type) {
    case 'email':
      return email === pattern;

    case 'domain':
      return domain === pattern || domain.endsWith(`.${pattern}`);

    case 'pattern':
      return matchesWildcard(email, pattern) || matchesWildcard(domain, pattern);

    default:
      return false;
  }
}

/**
 * Simple wildcard pattern matching
 * Supports * (any characters) and ? (single character)
 */
function matchesWildcard(text: string, pattern: string): boolean {
  // Convert wildcard pattern to regex
  const regexPattern = pattern
    .replace(/[.+^${}()|[\]\\]/g, '\\$&') // Escape regex special chars
    .replace(/\*/g, '.*') // * = any characters
    .replace(/\?/g, '.'); // ? = single character

  const regex = new RegExp(`^${regexPattern}$`, 'i');
  return regex.test(text);
}

/**
 * Validate a blacklist pattern
 */
export function validatePattern(
  pattern: string,
  type: BlacklistEntry['type']
): { valid: boolean; error?: string } {
  if (!pattern || !pattern.trim()) {
    return { valid: false, error: 'Pattern cannot be empty' };
  }

  const normalized = pattern.trim().toLowerCase();

  switch (type) {
    case 'email':
      // Basic email format check
      if (!normalized.includes('@')) {
        return { valid: false, error: 'Email must contain @' };
      }
      break;

    case 'domain':
      // Domain format check
      if (normalized.includes('@')) {
        return { valid: false, error: 'Domain should not contain @' };
      }
      if (!/^[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/.test(normalized)) {
        return { valid: false, error: 'Invalid domain format' };
      }
      break;

    case 'pattern':
      // Pattern can be more flexible
      if (normalized.length < 2) {
        return { valid: false, error: 'Pattern must be at least 2 characters' };
      }
      break;
  }

  return { valid: true };
}
```

### Step 4: Create Blacklist Index

Create `src/lib/blacklist/index.ts`:

```typescript
export { checkAgainstBlacklist, validatePattern } from './checker';
export * from './types';
```

### Step 5: Create Blacklist Validator

Create `src/lib/validators/blacklist.ts`:

```typescript
import { checkAgainstBlacklist, BlacklistCheckResult, Blacklist } from '../blacklist';

export interface CustomBlacklistResult {
  checked: boolean;
  result?: BlacklistCheckResult;
  message: string;
}

export function checkCustomBlacklist(
  email: string,
  blacklists: Blacklist[],
  options: { enabled?: boolean } = {}
): CustomBlacklistResult {
  const { enabled = true } = options;

  if (!enabled) {
    return {
      checked: false,
      message: 'Custom blacklist check disabled',
    };
  }

  if (!blacklists || blacklists.length === 0) {
    return {
      checked: false,
      message: 'No custom blacklists configured',
    };
  }

  const result = checkAgainstBlacklist(email, blacklists);

  return {
    checked: true,
    result,
    message: result.message,
  };
}
```

### Step 6: Create Blacklist Management UI

Create `src/components/blacklist/BlacklistManager.tsx`:

```typescript
'use client';

import { useState } from 'react';
import { useBlacklistStore } from '@/stores/blacklist-store';
import { validatePattern } from '@/lib/blacklist';
import { BlacklistEntry } from '@/lib/blacklist/types';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Plus,
  Trash2,
  Download,
  Upload,
  X,
  Check,
  List,
} from 'lucide-react';

export function BlacklistManager() {
  const {
    blacklists,
    activeBlacklistId,
    createBlacklist,
    deleteBlacklist,
    addEntry,
    removeEntry,
    toggleEntry,
    exportBlacklists,
    importBlacklists,
    setActiveBlacklist,
  } = useBlacklistStore();

  const [newListName, setNewListName] = useState('');
  const [newPattern, setNewPattern] = useState('');
  const [newPatternType, setNewPatternType] = useState<BlacklistEntry['type']>('domain');
  const [error, setError] = useState('');

  const activeBlacklist = blacklists.find((bl) => bl.id === activeBlacklistId);

  const handleCreateList = () => {
    if (!newListName.trim()) return;
    const newList = createBlacklist(newListName.trim());
    setActiveBlacklist(newList.id);
    setNewListName('');
  };

  const handleAddEntry = () => {
    if (!activeBlacklistId || !newPattern.trim()) return;

    const validation = validatePattern(newPattern, newPatternType);
    if (!validation.valid) {
      setError(validation.error || 'Invalid pattern');
      return;
    }

    addEntry(activeBlacklistId, {
      pattern: newPattern.trim().toLowerCase(),
      type: newPatternType,
      isActive: true,
    });

    setNewPattern('');
    setError('');
  };

  const handleExport = () => {
    const json = exportBlacklists();
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'blacklists.json';
    a.click();
    URL.revokeObjectURL(url);
  };

  const handleImport = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      const result = importBlacklists(event.target?.result as string);
      if (!result.success) {
        setError(result.message);
      }
    };
    reader.readAsText(file);
    e.target.value = '';
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <List className="h-5 w-5" />
          Custom Blacklists
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Create new blacklist */}
        <div className="flex gap-2">
          <Input
            placeholder="New blacklist name..."
            value={newListName}
            onChange={(e) => setNewListName(e.target.value)}
            onKeyDown={(e) => e.key === 'Enter' && handleCreateList()}
          />
          <Button onClick={handleCreateList} size="icon">
            <Plus className="h-4 w-4" />
          </Button>
        </div>

        {/* Blacklist selector */}
        {blacklists.length > 0 && (
          <Select
            value={activeBlacklistId || ''}
            onValueChange={setActiveBlacklist}
          >
            <SelectTrigger>
              <SelectValue placeholder="Select a blacklist" />
            </SelectTrigger>
            <SelectContent>
              {blacklists.map((bl) => (
                <SelectItem key={bl.id} value={bl.id}>
                  {bl.name} ({bl.entries.length} entries)
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        )}

        {/* Active blacklist entries */}
        {activeBlacklist && (
          <>
            {/* Add entry form */}
            <div className="flex gap-2">
              <Input
                placeholder="Pattern (e.g., spam.com, *@temp.com)"
                value={newPattern}
                onChange={(e) => setNewPattern(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && handleAddEntry()}
                className="flex-1"
              />
              <Select
                value={newPatternType}
                onValueChange={(v) => setNewPatternType(v as BlacklistEntry['type'])}
              >
                <SelectTrigger className="w-32">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="domain">Domain</SelectItem>
                  <SelectItem value="email">Email</SelectItem>
                  <SelectItem value="pattern">Pattern</SelectItem>
                </SelectContent>
              </Select>
              <Button onClick={handleAddEntry} size="icon">
                <Plus className="h-4 w-4" />
              </Button>
            </div>

            {error && <p className="text-sm text-red-500">{error}</p>}

            {/* Entries list */}
            <div className="max-h-64 overflow-y-auto space-y-2">
              {activeBlacklist.entries.map((entry) => (
                <div
                  key={entry.id}
                  className={`flex items-center justify-between p-2 rounded border ${
                    entry.isActive ? 'bg-background' : 'bg-muted opacity-60'
                  }`}
                >
                  <div className="flex items-center gap-2">
                    <Badge variant="outline">{entry.type}</Badge>
                    <span className="font-mono text-sm">{entry.pattern}</span>
                  </div>
                  <div className="flex items-center gap-1">
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => toggleEntry(activeBlacklist.id, entry.id)}
                    >
                      {entry.isActive ? (
                        <Check className="h-4 w-4 text-green-500" />
                      ) : (
                        <X className="h-4 w-4 text-muted-foreground" />
                      )}
                    </Button>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => removeEntry(activeBlacklist.id, entry.id)}
                    >
                      <Trash2 className="h-4 w-4 text-red-500" />
                    </Button>
                  </div>
                </div>
              ))}
            </div>

            {/* Delete blacklist */}
            <div className="flex justify-between pt-4 border-t">
              <Button
                variant="destructive"
                size="sm"
                onClick={() => deleteBlacklist(activeBlacklist.id)}
              >
                <Trash2 className="h-4 w-4 mr-2" />
                Delete Blacklist
              </Button>
            </div>
          </>
        )}

        {/* Import/Export */}
        <div className="flex gap-2 pt-4 border-t">
          <Button variant="outline" size="sm" onClick={handleExport}>
            <Download className="h-4 w-4 mr-2" />
            Export
          </Button>
          <label>
            <Button variant="outline" size="sm" asChild>
              <span>
                <Upload className="h-4 w-4 mr-2" />
                Import
              </span>
            </Button>
            <input
              type="file"
              accept=".json"
              onChange={handleImport}
              className="hidden"
            />
          </label>
        </div>
      </CardContent>
    </Card>
  );
}
```

### Step 7: Update Main Validator

Update `src/lib/validators/index.ts`:

```typescript
// Add to imports
import { checkCustomBlacklist, CustomBlacklistResult } from './blacklist';
import { Blacklist } from '../blacklist/types';

// Add to ValidationResult
interface ValidationResult {
  // ... existing fields
  checks: {
    // ... existing checks
    customBlacklist?: CustomBlacklistResult;
  };
}

// Add to validateEmail function
export async function validateEmail(
  email: string,
  options: {
    customBlacklists?: Blacklist[];
    // ... existing options
  } = {}
): Promise<ValidationResult> {
  // ... existing validation

  // Custom blacklist check (if provided)
  let blacklistResult: CustomBlacklistResult | undefined;
  if (options.customBlacklists && options.customBlacklists.length > 0) {
    blacklistResult = checkCustomBlacklist(email, options.customBlacklists, {
      enabled: true,
    });

    // Set as undeliverable if blacklisted
    if (blacklistResult.checked && blacklistResult.result?.isBlacklisted) {
      score = 0;
      deliverability = 'undeliverable';
      risk = 'high';
    }
  }

  return {
    // ... existing return
    checks: {
      // ... existing checks
      customBlacklist: blacklistResult,
    },
  };
}
```

### Step 8: Write Tests

Create `src/__tests__/lib/blacklist/blacklist.test.ts`:

```typescript
import { checkAgainstBlacklist, validatePattern } from '@/lib/blacklist';
import { Blacklist, BlacklistEntry } from '@/lib/blacklist/types';

describe('Custom Blacklist', () => {
  describe('checkAgainstBlacklist', () => {
    const createBlacklist = (entries: Partial<BlacklistEntry>[]): Blacklist => ({
      id: 'test',
      name: 'Test Blacklist',
      entries: entries.map((e, i) => ({
        id: `entry-${i}`,
        pattern: e.pattern || '',
        type: e.type || 'domain',
        createdAt: new Date(),
        isActive: e.isActive !== false,
        ...e,
      })),
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    test('matches exact domain', () => {
      const blacklist = createBlacklist([{ pattern: 'spam.com', type: 'domain' }]);
      const result = checkAgainstBlacklist('user@spam.com', [blacklist]);

      expect(result.isBlacklisted).toBe(true);
      expect(result.matchedEntries).toHaveLength(1);
    });

    test('matches subdomain', () => {
      const blacklist = createBlacklist([{ pattern: 'spam.com', type: 'domain' }]);
      const result = checkAgainstBlacklist('user@mail.spam.com', [blacklist]);

      expect(result.isBlacklisted).toBe(true);
    });

    test('matches exact email', () => {
      const blacklist = createBlacklist([{ pattern: 'bad@example.com', type: 'email' }]);
      const result = checkAgainstBlacklist('bad@example.com', [blacklist]);

      expect(result.isBlacklisted).toBe(true);
    });

    test('does not match different email', () => {
      const blacklist = createBlacklist([{ pattern: 'bad@example.com', type: 'email' }]);
      const result = checkAgainstBlacklist('good@example.com', [blacklist]);

      expect(result.isBlacklisted).toBe(false);
    });

    test('matches wildcard pattern', () => {
      const blacklist = createBlacklist([{ pattern: '*@temp*.com', type: 'pattern' }]);

      expect(checkAgainstBlacklist('user@tempmail.com', [blacklist]).isBlacklisted).toBe(true);
      expect(checkAgainstBlacklist('user@temporary.com', [blacklist]).isBlacklisted).toBe(true);
      expect(checkAgainstBlacklist('user@gmail.com', [blacklist]).isBlacklisted).toBe(false);
    });

    test('ignores inactive entries', () => {
      const blacklist = createBlacklist([
        { pattern: 'spam.com', type: 'domain', isActive: false },
      ]);
      const result = checkAgainstBlacklist('user@spam.com', [blacklist]);

      expect(result.isBlacklisted).toBe(false);
    });

    test('checks multiple blacklists', () => {
      const blacklist1 = createBlacklist([{ pattern: 'spam1.com', type: 'domain' }]);
      const blacklist2 = createBlacklist([{ pattern: 'spam2.com', type: 'domain' }]);

      const result1 = checkAgainstBlacklist('user@spam1.com', [blacklist1, blacklist2]);
      const result2 = checkAgainstBlacklist('user@spam2.com', [blacklist1, blacklist2]);

      expect(result1.isBlacklisted).toBe(true);
      expect(result2.isBlacklisted).toBe(true);
    });
  });

  describe('validatePattern', () => {
    test('validates domain patterns', () => {
      expect(validatePattern('example.com', 'domain').valid).toBe(true);
      expect(validatePattern('sub.example.com', 'domain').valid).toBe(true);
      expect(validatePattern('user@example.com', 'domain').valid).toBe(false);
      expect(validatePattern('', 'domain').valid).toBe(false);
    });

    test('validates email patterns', () => {
      expect(validatePattern('user@example.com', 'email').valid).toBe(true);
      expect(validatePattern('example.com', 'email').valid).toBe(false);
    });

    test('validates wildcard patterns', () => {
      expect(validatePattern('*.com', 'pattern').valid).toBe(true);
      expect(validatePattern('spam*', 'pattern').valid).toBe(true);
      expect(validatePattern('a', 'pattern').valid).toBe(false);
    });
  });
});
```

---

## Completion Checklist

```
[ ] Blacklist types defined
[ ] Blacklist store implemented
[ ] CRUD operations for blacklists
[ ] CRUD operations for entries
[ ] Pattern matching implemented
[ ] Wildcard support
[ ] Import/Export functionality
[ ] localStorage persistence
[ ] Validator created
[ ] Main validator updated
[ ] UI component created
[ ] Tests written and passing
[ ] All existing tests pass
[ ] Changes committed and pushed
```

---

## Next Milestone

After completing this milestone, proceed to:
`plans/milestones/8.1-webhooks.md`
