# Milestone 8.2: API Usage Dashboard

> **Phase:** 8 - API & Integrations
> **Status:** NOT STARTED
> **Priority:** MEDIUM
> **Complexity:** Medium
> **Estimated Time:** 4-5 hours

---

## Prompt for Claude Code

```
You are working on the Email Validator project. Your task is to implement an API usage dashboard.

IMPORTANT INSTRUCTIONS:
1. Read this entire file before starting
2. Follow the implementation steps in order
3. Write comprehensive tests
4. Update the checklist as you complete each task
5. Commit with message: "feat: add API usage dashboard with analytics"
6. Push the changes

PROJECT CONTEXT:
- API routes at src/app/api/
- State management with Zustand
- Use recharts for visualizations
- localStorage for persistence
```

---

## Objective

Implement an API usage dashboard showing:
- Request counts and trends
- Response time metrics
- Error rates
- Usage by endpoint
- Rate limit status
- Export functionality

---

## Implementation Steps

### Step 1: Create Analytics Types

Create `src/lib/analytics/types.ts`:

```typescript
export interface APIRequest {
  id: string;
  endpoint: string;
  method: string;
  statusCode: number;
  responseTimeMs: number;
  timestamp: Date;
  userAgent?: string;
  apiKey?: string;
  error?: string;
}

export interface UsageStats {
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  averageResponseTime: number;
  requestsByEndpoint: Record<string, number>;
  requestsByStatus: Record<number, number>;
  requestsByHour: HourlyStats[];
}

export interface HourlyStats {
  hour: string;
  requests: number;
  errors: number;
  avgResponseTime: number;
}

export interface DailyStats {
  date: string;
  requests: number;
  errors: number;
  avgResponseTime: number;
}

export interface EndpointStats {
  endpoint: string;
  requests: number;
  successRate: number;
  avgResponseTime: number;
  p95ResponseTime: number;
}
```

### Step 2: Create Analytics Store

Create `src/stores/analytics-store.ts`:

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { APIRequest, UsageStats, HourlyStats, DailyStats, EndpointStats } from '@/lib/analytics/types';

interface AnalyticsState {
  requests: APIRequest[];
  maxStoredRequests: number;

  // Recording
  recordRequest: (request: Omit<APIRequest, 'id'>) => void;
  clearRequests: () => void;

  // Statistics
  getUsageStats: (since?: Date) => UsageStats;
  getHourlyStats: (hours?: number) => HourlyStats[];
  getDailyStats: (days?: number) => DailyStats[];
  getEndpointStats: () => EndpointStats[];

  // Export
  exportData: (format: 'json' | 'csv') => string;
}

const generateId = () => `req_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;

export const useAnalyticsStore = create<AnalyticsState>()(
  persist(
    (set, get) => ({
      requests: [],
      maxStoredRequests: 10000,

      recordRequest: (request) => {
        const newRequest: APIRequest = {
          ...request,
          id: generateId(),
        };

        set((state) => ({
          requests: [newRequest, ...state.requests].slice(0, state.maxStoredRequests),
        }));
      },

      clearRequests: () => {
        set({ requests: [] });
      },

      getUsageStats: (since) => {
        const requests = get().requests.filter(
          (r) => !since || new Date(r.timestamp) >= since
        );

        const totalRequests = requests.length;
        const successfulRequests = requests.filter((r) => r.statusCode < 400).length;
        const failedRequests = totalRequests - successfulRequests;

        const totalResponseTime = requests.reduce((sum, r) => sum + r.responseTimeMs, 0);
        const averageResponseTime = totalRequests > 0 ? totalResponseTime / totalRequests : 0;

        const requestsByEndpoint: Record<string, number> = {};
        const requestsByStatus: Record<number, number> = {};

        requests.forEach((r) => {
          requestsByEndpoint[r.endpoint] = (requestsByEndpoint[r.endpoint] || 0) + 1;
          requestsByStatus[r.statusCode] = (requestsByStatus[r.statusCode] || 0) + 1;
        });

        return {
          totalRequests,
          successfulRequests,
          failedRequests,
          averageResponseTime: Math.round(averageResponseTime),
          requestsByEndpoint,
          requestsByStatus,
          requestsByHour: get().getHourlyStats(24),
        };
      },

      getHourlyStats: (hours = 24) => {
        const now = new Date();
        const cutoff = new Date(now.getTime() - hours * 60 * 60 * 1000);
        const requests = get().requests.filter((r) => new Date(r.timestamp) >= cutoff);

        const hourlyMap = new Map<string, APIRequest[]>();

        requests.forEach((r) => {
          const date = new Date(r.timestamp);
          const hourKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:00`;

          if (!hourlyMap.has(hourKey)) {
            hourlyMap.set(hourKey, []);
          }
          hourlyMap.get(hourKey)!.push(r);
        });

        const stats: HourlyStats[] = [];

        for (let i = hours - 1; i >= 0; i--) {
          const date = new Date(now.getTime() - i * 60 * 60 * 1000);
          const hourKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:00`;

          const hourRequests = hourlyMap.get(hourKey) || [];
          const errors = hourRequests.filter((r) => r.statusCode >= 400).length;
          const totalTime = hourRequests.reduce((sum, r) => sum + r.responseTimeMs, 0);

          stats.push({
            hour: hourKey,
            requests: hourRequests.length,
            errors,
            avgResponseTime: hourRequests.length > 0 ? Math.round(totalTime / hourRequests.length) : 0,
          });
        }

        return stats;
      },

      getDailyStats: (days = 30) => {
        const now = new Date();
        const cutoff = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
        const requests = get().requests.filter((r) => new Date(r.timestamp) >= cutoff);

        const dailyMap = new Map<string, APIRequest[]>();

        requests.forEach((r) => {
          const date = new Date(r.timestamp);
          const dayKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;

          if (!dailyMap.has(dayKey)) {
            dailyMap.set(dayKey, []);
          }
          dailyMap.get(dayKey)!.push(r);
        });

        const stats: DailyStats[] = [];

        for (let i = days - 1; i >= 0; i--) {
          const date = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
          const dayKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;

          const dayRequests = dailyMap.get(dayKey) || [];
          const errors = dayRequests.filter((r) => r.statusCode >= 400).length;
          const totalTime = dayRequests.reduce((sum, r) => sum + r.responseTimeMs, 0);

          stats.push({
            date: dayKey,
            requests: dayRequests.length,
            errors,
            avgResponseTime: dayRequests.length > 0 ? Math.round(totalTime / dayRequests.length) : 0,
          });
        }

        return stats;
      },

      getEndpointStats: () => {
        const requests = get().requests;
        const endpointMap = new Map<string, APIRequest[]>();

        requests.forEach((r) => {
          if (!endpointMap.has(r.endpoint)) {
            endpointMap.set(r.endpoint, []);
          }
          endpointMap.get(r.endpoint)!.push(r);
        });

        const stats: EndpointStats[] = [];

        endpointMap.forEach((reqs, endpoint) => {
          const successful = reqs.filter((r) => r.statusCode < 400).length;
          const responseTimes = reqs.map((r) => r.responseTimeMs).sort((a, b) => a - b);
          const totalTime = responseTimes.reduce((sum, t) => sum + t, 0);
          const p95Index = Math.floor(responseTimes.length * 0.95);

          stats.push({
            endpoint,
            requests: reqs.length,
            successRate: (successful / reqs.length) * 100,
            avgResponseTime: Math.round(totalTime / reqs.length),
            p95ResponseTime: responseTimes[p95Index] || 0,
          });
        });

        return stats.sort((a, b) => b.requests - a.requests);
      },

      exportData: (format) => {
        const requests = get().requests;

        if (format === 'json') {
          return JSON.stringify(requests, null, 2);
        }

        // CSV format
        const headers = ['id', 'endpoint', 'method', 'statusCode', 'responseTimeMs', 'timestamp', 'error'];
        const rows = requests.map((r) => [
          r.id,
          r.endpoint,
          r.method,
          r.statusCode,
          r.responseTimeMs,
          new Date(r.timestamp).toISOString(),
          r.error || '',
        ]);

        return [headers.join(','), ...rows.map((r) => r.join(','))].join('\n');
      },
    }),
    {
      name: 'email-validator-analytics',
      partialize: (state) => ({
        requests: state.requests.slice(0, 5000), // Only persist last 5000 requests
      }),
    }
  )
);
```

### Step 3: Create Analytics Middleware

Create `src/lib/analytics/middleware.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';

export interface RequestMetrics {
  endpoint: string;
  method: string;
  statusCode: number;
  responseTimeMs: number;
  timestamp: Date;
  userAgent?: string;
  apiKey?: string;
  error?: string;
}

/**
 * Wrap an API handler to track metrics
 */
export function withAnalytics<T>(
  handler: (request: NextRequest) => Promise<NextResponse<T>>,
  recordMetrics: (metrics: RequestMetrics) => void
) {
  return async (request: NextRequest): Promise<NextResponse<T>> => {
    const startTime = performance.now();
    const endpoint = new URL(request.url).pathname;
    const method = request.method;
    const userAgent = request.headers.get('user-agent') || undefined;
    const apiKey = request.headers.get('x-api-key') || undefined;

    let statusCode = 200;
    let error: string | undefined;

    try {
      const response = await handler(request);
      statusCode = response.status;
      return response;
    } catch (err) {
      statusCode = 500;
      error = err instanceof Error ? err.message : 'Unknown error';
      throw err;
    } finally {
      const responseTimeMs = Math.round(performance.now() - startTime);

      recordMetrics({
        endpoint,
        method,
        statusCode,
        responseTimeMs,
        timestamp: new Date(),
        userAgent,
        apiKey,
        error,
      });
    }
  };
}
```

### Step 4: Create Dashboard Components

Create `src/components/analytics/UsageOverview.tsx`:

```typescript
'use client';

import { useAnalyticsStore } from '@/stores/analytics-store';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Activity, CheckCircle, XCircle, Clock } from 'lucide-react';

export function UsageOverview() {
  const { getUsageStats } = useAnalyticsStore();

  // Get stats for last 24 hours
  const since = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const stats = getUsageStats(since);

  const successRate = stats.totalRequests > 0
    ? ((stats.successfulRequests / stats.totalRequests) * 100).toFixed(1)
    : '0';

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Total Requests</CardTitle>
          <Activity className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stats.totalRequests.toLocaleString()}</div>
          <p className="text-xs text-muted-foreground">Last 24 hours</p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Success Rate</CardTitle>
          <CheckCircle className="h-4 w-4 text-green-500" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{successRate}%</div>
          <p className="text-xs text-muted-foreground">
            {stats.successfulRequests.toLocaleString()} successful
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Failed Requests</CardTitle>
          <XCircle className="h-4 w-4 text-red-500" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stats.failedRequests.toLocaleString()}</div>
          <p className="text-xs text-muted-foreground">Errors in last 24h</p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Avg Response Time</CardTitle>
          <Clock className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{stats.averageResponseTime}ms</div>
          <p className="text-xs text-muted-foreground">Average latency</p>
        </CardContent>
      </Card>
    </div>
  );
}
```

Create `src/components/analytics/RequestsChart.tsx`:

```typescript
'use client';

import { useAnalyticsStore } from '@/stores/analytics-store';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from 'recharts';

interface RequestsChartProps {
  timeRange: 'hourly' | 'daily';
}

export function RequestsChart({ timeRange }: RequestsChartProps) {
  const { getHourlyStats, getDailyStats } = useAnalyticsStore();

  const data = timeRange === 'hourly'
    ? getHourlyStats(24)
    : getDailyStats(30);

  const formatXAxis = (value: string) => {
    if (timeRange === 'hourly') {
      return value.split(' ')[1] || value;
    }
    return value.split('-').slice(1).join('/');
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>
          Request Volume ({timeRange === 'hourly' ? 'Last 24 Hours' : 'Last 30 Days'})
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-[300px]">
          <ResponsiveContainer width="100%" height="100%">
            <LineChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey={timeRange === 'hourly' ? 'hour' : 'date'}
                tickFormatter={formatXAxis}
                tick={{ fontSize: 12 }}
              />
              <YAxis tick={{ fontSize: 12 }} />
              <Tooltip />
              <Legend />
              <Line
                type="monotone"
                dataKey="requests"
                stroke="#2563eb"
                name="Requests"
                strokeWidth={2}
              />
              <Line
                type="monotone"
                dataKey="errors"
                stroke="#dc2626"
                name="Errors"
                strokeWidth={2}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
}
```

Create `src/components/analytics/EndpointTable.tsx`:

```typescript
'use client';

import { useAnalyticsStore } from '@/stores/analytics-store';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';

export function EndpointTable() {
  const { getEndpointStats } = useAnalyticsStore();
  const stats = getEndpointStats();

  const getSuccessRateColor = (rate: number) => {
    if (rate >= 99) return 'text-green-600';
    if (rate >= 95) return 'text-yellow-600';
    return 'text-red-600';
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Endpoint Performance</CardTitle>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Endpoint</TableHead>
              <TableHead className="text-right">Requests</TableHead>
              <TableHead className="text-right">Success Rate</TableHead>
              <TableHead className="text-right">Avg Response</TableHead>
              <TableHead className="text-right">P95 Response</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {stats.map((stat) => (
              <TableRow key={stat.endpoint}>
                <TableCell className="font-mono text-sm">{stat.endpoint}</TableCell>
                <TableCell className="text-right">{stat.requests.toLocaleString()}</TableCell>
                <TableCell className={`text-right ${getSuccessRateColor(stat.successRate)}`}>
                  {stat.successRate.toFixed(1)}%
                </TableCell>
                <TableCell className="text-right">{stat.avgResponseTime}ms</TableCell>
                <TableCell className="text-right">{stat.p95ResponseTime}ms</TableCell>
              </TableRow>
            ))}
            {stats.length === 0 && (
              <TableRow>
                <TableCell colSpan={5} className="text-center text-muted-foreground">
                  No endpoint data available
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  );
}
```

Create `src/components/analytics/ResponseTimeChart.tsx`:

```typescript
'use client';

import { useAnalyticsStore } from '@/stores/analytics-store';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
} from 'recharts';

export function ResponseTimeChart() {
  const { getHourlyStats } = useAnalyticsStore();
  const data = getHourlyStats(24);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Response Time (Last 24 Hours)</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-[250px]">
          <ResponsiveContainer width="100%" height="100%">
            <AreaChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="hour"
                tickFormatter={(value) => value.split(' ')[1] || value}
                tick={{ fontSize: 12 }}
              />
              <YAxis tick={{ fontSize: 12 }} unit="ms" />
              <Tooltip
                formatter={(value: number) => [`${value}ms`, 'Avg Response Time']}
              />
              <Area
                type="monotone"
                dataKey="avgResponseTime"
                stroke="#8b5cf6"
                fill="#8b5cf6"
                fillOpacity={0.3}
              />
            </AreaChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
}
```

### Step 5: Create Dashboard Page

Create `src/app/analytics/page.tsx`:

```typescript
'use client';

import { useState } from 'react';
import { useAnalyticsStore } from '@/stores/analytics-store';
import { UsageOverview } from '@/components/analytics/UsageOverview';
import { RequestsChart } from '@/components/analytics/RequestsChart';
import { EndpointTable } from '@/components/analytics/EndpointTable';
import { ResponseTimeChart } from '@/components/analytics/ResponseTimeChart';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Download, Trash2 } from 'lucide-react';

export default function AnalyticsPage() {
  const { exportData, clearRequests } = useAnalyticsStore();
  const [timeRange, setTimeRange] = useState<'hourly' | 'daily'>('hourly');

  const handleExport = (format: 'json' | 'csv') => {
    const data = exportData(format);
    const blob = new Blob([data], {
      type: format === 'json' ? 'application/json' : 'text/csv',
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `api-usage.${format}`;
    a.click();
    URL.revokeObjectURL(url);
  };

  return (
    <div className="container mx-auto py-8 space-y-8">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">API Usage Dashboard</h1>
          <p className="text-muted-foreground">Monitor your API usage and performance</p>
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={() => handleExport('json')}>
            <Download className="h-4 w-4 mr-2" />
            Export JSON
          </Button>
          <Button variant="outline" onClick={() => handleExport('csv')}>
            <Download className="h-4 w-4 mr-2" />
            Export CSV
          </Button>
          <Button variant="destructive" onClick={clearRequests}>
            <Trash2 className="h-4 w-4 mr-2" />
            Clear Data
          </Button>
        </div>
      </div>

      <UsageOverview />

      <Tabs defaultValue="hourly" onValueChange={(v) => setTimeRange(v as 'hourly' | 'daily')}>
        <TabsList>
          <TabsTrigger value="hourly">Hourly</TabsTrigger>
          <TabsTrigger value="daily">Daily</TabsTrigger>
        </TabsList>
        <TabsContent value="hourly" className="space-y-4">
          <RequestsChart timeRange="hourly" />
        </TabsContent>
        <TabsContent value="daily" className="space-y-4">
          <RequestsChart timeRange="daily" />
        </TabsContent>
      </Tabs>

      <div className="grid gap-4 lg:grid-cols-2">
        <ResponseTimeChart />
        <EndpointTable />
      </div>
    </div>
  );
}
```

### Step 6: Install recharts

Add to `package.json` or run:

```bash
npm install recharts
```

### Step 7: Write Tests

Create `src/__tests__/stores/analytics-store.test.ts`:

```typescript
import { act } from '@testing-library/react';

// Mock localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
Object.defineProperty(window, 'localStorage', { value: localStorageMock });

import { useAnalyticsStore } from '@/stores/analytics-store';

describe('Analytics Store', () => {
  beforeEach(() => {
    const store = useAnalyticsStore.getState();
    store.clearRequests();
  });

  describe('recordRequest', () => {
    test('adds request to store', () => {
      const store = useAnalyticsStore.getState();

      act(() => {
        store.recordRequest({
          endpoint: '/api/validate',
          method: 'POST',
          statusCode: 200,
          responseTimeMs: 100,
          timestamp: new Date(),
        });
      });

      expect(store.requests).toHaveLength(1);
      expect(store.requests[0].endpoint).toBe('/api/validate');
    });

    test('limits stored requests', () => {
      const store = useAnalyticsStore.getState();

      act(() => {
        for (let i = 0; i < 100; i++) {
          store.recordRequest({
            endpoint: '/api/validate',
            method: 'POST',
            statusCode: 200,
            responseTimeMs: 100,
            timestamp: new Date(),
          });
        }
      });

      expect(store.requests.length).toBeLessThanOrEqual(store.maxStoredRequests);
    });
  });

  describe('getUsageStats', () => {
    test('calculates correct statistics', () => {
      const store = useAnalyticsStore.getState();

      act(() => {
        store.recordRequest({
          endpoint: '/api/validate',
          method: 'POST',
          statusCode: 200,
          responseTimeMs: 100,
          timestamp: new Date(),
        });
        store.recordRequest({
          endpoint: '/api/validate',
          method: 'POST',
          statusCode: 500,
          responseTimeMs: 200,
          timestamp: new Date(),
        });
      });

      const stats = store.getUsageStats();

      expect(stats.totalRequests).toBe(2);
      expect(stats.successfulRequests).toBe(1);
      expect(stats.failedRequests).toBe(1);
      expect(stats.averageResponseTime).toBe(150);
    });

    test('filters by date', () => {
      const store = useAnalyticsStore.getState();
      const now = new Date();
      const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);

      act(() => {
        store.recordRequest({
          endpoint: '/api/validate',
          method: 'POST',
          statusCode: 200,
          responseTimeMs: 100,
          timestamp: now,
        });
      });

      const stats = store.getUsageStats(yesterday);
      expect(stats.totalRequests).toBe(1);

      const futureStats = store.getUsageStats(new Date(now.getTime() + 1000));
      expect(futureStats.totalRequests).toBe(0);
    });
  });

  describe('getEndpointStats', () => {
    test('groups by endpoint', () => {
      const store = useAnalyticsStore.getState();

      act(() => {
        store.recordRequest({
          endpoint: '/api/validate',
          method: 'POST',
          statusCode: 200,
          responseTimeMs: 100,
          timestamp: new Date(),
        });
        store.recordRequest({
          endpoint: '/api/validate-bulk',
          method: 'POST',
          statusCode: 200,
          responseTimeMs: 200,
          timestamp: new Date(),
        });
      });

      const stats = store.getEndpointStats();

      expect(stats).toHaveLength(2);
      expect(stats.find((s) => s.endpoint === '/api/validate')).toBeTruthy();
    });
  });

  describe('exportData', () => {
    test('exports as JSON', () => {
      const store = useAnalyticsStore.getState();

      act(() => {
        store.recordRequest({
          endpoint: '/api/validate',
          method: 'POST',
          statusCode: 200,
          responseTimeMs: 100,
          timestamp: new Date(),
        });
      });

      const json = store.exportData('json');
      const parsed = JSON.parse(json);

      expect(Array.isArray(parsed)).toBe(true);
      expect(parsed[0].endpoint).toBe('/api/validate');
    });

    test('exports as CSV', () => {
      const store = useAnalyticsStore.getState();

      act(() => {
        store.recordRequest({
          endpoint: '/api/validate',
          method: 'POST',
          statusCode: 200,
          responseTimeMs: 100,
          timestamp: new Date(),
        });
      });

      const csv = store.exportData('csv');
      const lines = csv.split('\n');

      expect(lines[0]).toContain('endpoint');
      expect(lines[1]).toContain('/api/validate');
    });
  });
});
```

---

## Completion Checklist

```
[ ] Analytics types defined
[ ] Analytics store created
[ ] Request recording
[ ] Usage statistics calculation
[ ] Hourly/daily stats
[ ] Endpoint stats with P95
[ ] Analytics middleware created
[ ] Dashboard overview component
[ ] Requests chart with recharts
[ ] Response time chart
[ ] Endpoint performance table
[ ] Dashboard page created
[ ] Export functionality (JSON/CSV)
[ ] Clear data functionality
[ ] Tests written and passing
[ ] All existing tests pass
[ ] Changes committed and pushed
```

---

## Next Milestone

After completing this milestone, proceed to:
`plans/milestones/8.3-nodejs-sdk.md`
