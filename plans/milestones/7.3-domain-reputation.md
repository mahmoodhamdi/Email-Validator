# Milestone 7.3: Domain Reputation

> **Phase:** 7 - Advanced Validation
> **Status:** COMPLETED
> **Priority:** MEDIUM
> **Complexity:** Medium
> **Estimated Time:** 4-5 hours

---

## Prompt for Claude Code

```
You are working on the Email Validator project. Your task is to implement domain reputation checking.

IMPORTANT INSTRUCTIONS:
1. Read this entire file before starting
2. Follow the implementation steps in order
3. Write comprehensive tests
4. Update the checklist as you complete each task
5. Commit with message: "feat: add domain reputation scoring"
6. Push the changes

PROJECT CONTEXT:
- Existing validators are in src/lib/validators/
- Cache system in src/lib/cache.ts
- Types in src/types/email.ts
- Use free APIs where possible (no paid services)
```

---

## Objective

Implement domain reputation checking to assess email domain trustworthiness:
- Check domain age (newer domains are riskier)
- Check against spam blocklists (free services)
- Analyze domain registration info
- Calculate reputation score
- Display results in UI

---

## Implementation Steps

### Step 1: Create Reputation Types

Create `src/lib/reputation/types.ts`:

```typescript
export interface DomainAge {
  createdDate: Date | null;
  ageInDays: number | null;
  isNew: boolean;  // Less than 30 days
  isYoung: boolean;  // Less than 180 days
  message: string;
}

export interface BlocklistResult {
  listed: boolean;
  lists: BlocklistEntry[];
  checkedCount: number;
  message: string;
}

export interface BlocklistEntry {
  name: string;
  listed: boolean;
  type: 'spam' | 'phishing' | 'malware' | 'general';
  url?: string;
}

export interface DomainInfo {
  domain: string;
  registrar?: string;
  nameservers?: string[];
  hasWhoisPrivacy: boolean;
}

export interface ReputationResult {
  score: number;  // 0-100
  risk: 'low' | 'medium' | 'high' | 'critical';
  age: DomainAge;
  blocklists: BlocklistResult;
  domainInfo: DomainInfo;
  factors: ReputationFactor[];
  summary: string;
}

export interface ReputationFactor {
  name: string;
  impact: 'positive' | 'negative' | 'neutral';
  score: number;
  description: string;
}
```

### Step 2: Create Domain Age Checker

Create `src/lib/reputation/age.ts`:

```typescript
import { DomainAge } from './types';

// We'll estimate age based on RDAP/WHOIS when available
// For simplicity, we'll use heuristics and DNS-based checks

export async function checkDomainAge(domain: string): Promise<DomainAge> {
  try {
    // Try to get domain creation date via public RDAP
    const rdapResult = await fetchRDAP(domain);

    if (rdapResult?.createdDate) {
      const createdDate = new Date(rdapResult.createdDate);
      const now = new Date();
      const ageInDays = Math.floor((now.getTime() - createdDate.getTime()) / (1000 * 60 * 60 * 24));

      return {
        createdDate,
        ageInDays,
        isNew: ageInDays < 30,
        isYoung: ageInDays < 180,
        message: formatAgeMessage(ageInDays),
      };
    }

    // Fallback: Can't determine age
    return {
      createdDate: null,
      ageInDays: null,
      isNew: false,
      isYoung: false,
      message: 'Domain age could not be determined',
    };
  } catch {
    return {
      createdDate: null,
      ageInDays: null,
      isNew: false,
      isYoung: false,
      message: 'Failed to check domain age',
    };
  }
}

async function fetchRDAP(domain: string): Promise<{ createdDate?: string } | null> {
  // Extract TLD and try RDAP servers
  const tld = domain.split('.').pop()?.toLowerCase();
  if (!tld) return null;

  // RDAP bootstrap for common TLDs
  const rdapServers: Record<string, string> = {
    com: 'https://rdap.verisign.com/com/v1/domain/',
    net: 'https://rdap.verisign.com/net/v1/domain/',
    org: 'https://rdap.publicinterestregistry.org/rdap/domain/',
    io: 'https://rdap.nic.io/domain/',
  };

  const server = rdapServers[tld];
  if (!server) return null;

  try {
    const response = await fetch(`${server}${domain}`, {
      headers: { Accept: 'application/rdap+json' },
      signal: AbortSignal.timeout(5000),
    });

    if (!response.ok) return null;

    const data = await response.json();

    // Find registration event
    const events = data.events || [];
    const registration = events.find((e: any) => e.eventAction === 'registration');

    return {
      createdDate: registration?.eventDate,
    };
  } catch {
    return null;
  }
}

function formatAgeMessage(ageInDays: number): string {
  if (ageInDays < 7) {
    return `Domain registered ${ageInDays} days ago (very new - high risk)`;
  } else if (ageInDays < 30) {
    return `Domain registered ${ageInDays} days ago (new domain)`;
  } else if (ageInDays < 180) {
    const months = Math.floor(ageInDays / 30);
    return `Domain is ${months} month(s) old`;
  } else if (ageInDays < 365) {
    const months = Math.floor(ageInDays / 30);
    return `Domain is ${months} months old`;
  } else {
    const years = Math.floor(ageInDays / 365);
    return `Domain is ${years}+ year(s) old (established)`;
  }
}
```

### Step 3: Create Blocklist Checker

Create `src/lib/reputation/blocklist.ts`:

```typescript
import { BlocklistResult, BlocklistEntry } from './types';

// Free DNS-based blocklists (DNSBL)
const DNS_BLOCKLISTS = [
  {
    name: 'Spamhaus DBL',
    zone: 'dbl.spamhaus.org',
    type: 'spam' as const,
    url: 'https://www.spamhaus.org/dbl/',
  },
  {
    name: 'SURBL',
    zone: 'multi.surbl.org',
    type: 'spam' as const,
    url: 'https://www.surbl.org/',
  },
  {
    name: 'URIBL',
    zone: 'multi.uribl.com',
    type: 'spam' as const,
    url: 'https://uribl.com/',
  },
];

// Local blocklist patterns (suspicious patterns)
const SUSPICIOUS_PATTERNS = [
  /^[a-z]{20,}\./, // Very long random subdomain
  /^\d{5,}\./, // Many numbers at start
  /[.-]{3,}/, // Multiple consecutive separators
  /\.(xyz|top|work|click|link|gq|ml|cf|tk|ga)$/i, // High-risk TLDs
];

export async function checkBlocklists(domain: string): Promise<BlocklistResult> {
  const results: BlocklistEntry[] = [];
  let listedCount = 0;

  // Check DNS-based blocklists
  for (const blocklist of DNS_BLOCKLISTS) {
    const entry = await checkDNSBL(domain, blocklist);
    results.push(entry);
    if (entry.listed) listedCount++;
  }

  // Check local patterns
  const patternCheck = checkSuspiciousPatterns(domain);
  if (patternCheck.listed) {
    results.push(patternCheck);
    listedCount++;
  }

  return {
    listed: listedCount > 0,
    lists: results,
    checkedCount: results.length,
    message: listedCount > 0
      ? `Listed on ${listedCount} blocklist(s)`
      : 'Not found on any blocklists',
  };
}

async function checkDNSBL(
  domain: string,
  blocklist: typeof DNS_BLOCKLISTS[0]
): Promise<BlocklistEntry> {
  try {
    // DNS-based blocklist lookup
    const lookupDomain = `${domain}.${blocklist.zone}`;

    // Use DNS over HTTPS for browser compatibility
    const response = await fetch(
      `https://dns.google/resolve?name=${encodeURIComponent(lookupDomain)}&type=A`,
      { signal: AbortSignal.timeout(3000) }
    );

    if (!response.ok) {
      return {
        name: blocklist.name,
        listed: false,
        type: blocklist.type,
        url: blocklist.url,
      };
    }

    const data = await response.json();

    // If we get an answer, the domain is listed
    const listed = data.Answer && data.Answer.length > 0;

    return {
      name: blocklist.name,
      listed,
      type: blocklist.type,
      url: blocklist.url,
    };
  } catch {
    // Network error or timeout - assume not listed
    return {
      name: blocklist.name,
      listed: false,
      type: blocklist.type,
      url: blocklist.url,
    };
  }
}

function checkSuspiciousPatterns(domain: string): BlocklistEntry {
  const isSuspicious = SUSPICIOUS_PATTERNS.some(pattern => pattern.test(domain));

  return {
    name: 'Suspicious Pattern Detection',
    listed: isSuspicious,
    type: 'general',
  };
}
```

### Step 4: Create Reputation Calculator

Create `src/lib/reputation/index.ts`:

```typescript
import { checkDomainAge } from './age';
import { checkBlocklists } from './blocklist';
import { ReputationResult, ReputationFactor, DomainInfo } from './types';
import { LRUCache } from '../cache';

// Cache reputation results
const reputationCache = new LRUCache<ReputationResult>({
  maxSize: 500,
  ttlMs: 30 * 60 * 1000, // 30 minutes
  name: 'reputation',
});

export async function checkDomainReputation(domain: string): Promise<ReputationResult> {
  // Check cache
  const cached = reputationCache.get(domain);
  if (cached) {
    return cached;
  }

  // Run checks in parallel
  const [age, blocklists] = await Promise.all([
    checkDomainAge(domain),
    checkBlocklists(domain),
  ]);

  // Build domain info
  const domainInfo: DomainInfo = {
    domain,
    hasWhoisPrivacy: false, // Would need WHOIS lookup
  };

  // Calculate factors and score
  const factors = calculateFactors(age, blocklists, domain);
  const score = calculateScore(factors);
  const risk = determineRisk(score);
  const summary = generateSummary(score, factors);

  const result: ReputationResult = {
    score,
    risk,
    age,
    blocklists,
    domainInfo,
    factors,
    summary,
  };

  // Cache result
  reputationCache.set(domain, result);

  return result;
}

function calculateFactors(
  age: ReputationResult['age'],
  blocklists: ReputationResult['blocklists'],
  domain: string
): ReputationFactor[] {
  const factors: ReputationFactor[] = [];

  // Age factor
  if (age.ageInDays !== null) {
    if (age.ageInDays < 7) {
      factors.push({
        name: 'Very New Domain',
        impact: 'negative',
        score: -40,
        description: 'Domain registered less than a week ago',
      });
    } else if (age.isNew) {
      factors.push({
        name: 'New Domain',
        impact: 'negative',
        score: -25,
        description: 'Domain registered less than 30 days ago',
      });
    } else if (age.isYoung) {
      factors.push({
        name: 'Young Domain',
        impact: 'negative',
        score: -10,
        description: 'Domain registered less than 6 months ago',
      });
    } else if (age.ageInDays > 365 * 2) {
      factors.push({
        name: 'Established Domain',
        impact: 'positive',
        score: 20,
        description: 'Domain is more than 2 years old',
      });
    }
  }

  // Blocklist factors
  if (blocklists.listed) {
    const listedCount = blocklists.lists.filter(l => l.listed).length;
    factors.push({
      name: 'Blocklisted',
      impact: 'negative',
      score: -30 * listedCount,
      description: `Found on ${listedCount} blocklist(s)`,
    });
  } else {
    factors.push({
      name: 'Clean Record',
      impact: 'positive',
      score: 15,
      description: 'Not found on any blocklists',
    });
  }

  // TLD factors
  const tld = domain.split('.').pop()?.toLowerCase();
  const highRiskTLDs = ['xyz', 'top', 'work', 'click', 'link', 'gq', 'ml', 'cf', 'tk', 'ga'];
  const premiumTLDs = ['com', 'net', 'org', 'edu', 'gov', 'io', 'co'];

  if (tld && highRiskTLDs.includes(tld)) {
    factors.push({
      name: 'High-Risk TLD',
      impact: 'negative',
      score: -15,
      description: `The .${tld} TLD is associated with higher spam rates`,
    });
  } else if (tld && premiumTLDs.includes(tld)) {
    factors.push({
      name: 'Premium TLD',
      impact: 'positive',
      score: 10,
      description: `The .${tld} TLD is a well-established extension`,
    });
  }

  // Domain length factor
  const domainWithoutTLD = domain.split('.')[0];
  if (domainWithoutTLD.length > 25) {
    factors.push({
      name: 'Long Domain Name',
      impact: 'negative',
      score: -5,
      description: 'Unusually long domain name',
    });
  }

  return factors;
}

function calculateScore(factors: ReputationFactor[]): number {
  // Start with base score of 70
  let score = 70;

  for (const factor of factors) {
    score += factor.score;
  }

  // Clamp to 0-100
  return Math.max(0, Math.min(100, score));
}

function determineRisk(score: number): ReputationResult['risk'] {
  if (score >= 80) return 'low';
  if (score >= 60) return 'medium';
  if (score >= 40) return 'high';
  return 'critical';
}

function generateSummary(score: number, factors: ReputationFactor[]): string {
  const negativeFactors = factors.filter(f => f.impact === 'negative');

  if (score >= 80) {
    return 'Domain has good reputation with no significant risk factors';
  } else if (score >= 60) {
    return `Domain has moderate reputation. ${negativeFactors.length} risk factor(s) detected`;
  } else if (score >= 40) {
    return `Domain has concerning reputation. Multiple risk factors detected`;
  } else {
    return 'Domain has poor reputation and should be treated with caution';
  }
}

export * from './types';
export { checkDomainAge } from './age';
export { checkBlocklists } from './blocklist';
```

### Step 5: Create Reputation Validator

Create `src/lib/validators/reputation.ts`:

```typescript
import { checkDomainReputation, ReputationResult } from '../reputation';

export interface ReputationCheckResult {
  checked: boolean;
  reputation?: ReputationResult;
  message: string;
}

export async function checkReputation(
  domain: string,
  options: { enabled?: boolean } = {}
): Promise<ReputationCheckResult> {
  const { enabled = true } = options;

  if (!enabled) {
    return {
      checked: false,
      message: 'Reputation check disabled',
    };
  }

  try {
    const reputation = await checkDomainReputation(domain);

    return {
      checked: true,
      reputation,
      message: reputation.summary,
    };
  } catch (error) {
    return {
      checked: false,
      message: error instanceof Error ? error.message : 'Reputation check failed',
    };
  }
}
```

### Step 6: Update Main Validator

Update `src/lib/validators/index.ts`:

```typescript
// Add to imports
import { checkReputation, ReputationCheckResult } from './reputation';

// Add to ValidationResult
interface ValidationResult {
  // ... existing fields
  checks: {
    // ... existing checks
    reputation?: ReputationCheckResult;
  };
}

// Add to validateEmail function
export async function validateEmail(
  email: string,
  options: {
    reputationCheck?: boolean;
    // ... existing options
  } = {}
): Promise<ValidationResult> {
  // ... existing validation

  // Reputation check (optional)
  let reputationResult: ReputationCheckResult | undefined;
  if (options.reputationCheck && domain) {
    reputationResult = await checkReputation(domain, { enabled: true });

    // Adjust score based on reputation
    if (reputationResult.checked && reputationResult.reputation) {
      const repScore = reputationResult.reputation.score;
      if (repScore < 40) {
        score = Math.min(score, 40);
        risk = 'high';
      } else if (repScore < 60) {
        score = Math.max(score - 15, 0);
      }
    }
  }

  return {
    // ... existing return
    checks: {
      // ... existing checks
      reputation: reputationResult,
    },
  };
}
```

### Step 7: Update UI

Update `src/components/email/ValidationResult.tsx`:

```typescript
// Add reputation section
{result.checks.reputation?.checked && result.checks.reputation.reputation && (
  <div className="border-t pt-4 mt-4">
    <h4 className="font-semibold flex items-center gap-2">
      <Globe className="h-4 w-4" />
      Domain Reputation
    </h4>
    <div className="mt-2 space-y-2 text-sm">
      {/* Reputation Score */}
      <div className="flex justify-between items-center">
        <span>Reputation Score:</span>
        <span className={`font-medium ${
          result.checks.reputation.reputation.score >= 80 ? 'text-green-600' :
          result.checks.reputation.reputation.score >= 60 ? 'text-yellow-600' :
          result.checks.reputation.reputation.score >= 40 ? 'text-orange-600' :
          'text-red-600'
        }`}>
          {result.checks.reputation.reputation.score}/100
        </span>
      </div>

      {/* Risk Level */}
      <div className="flex justify-between items-center">
        <span>Risk Level:</span>
        <Badge variant={
          result.checks.reputation.reputation.risk === 'low' ? 'success' :
          result.checks.reputation.reputation.risk === 'medium' ? 'warning' :
          'destructive'
        }>
          {result.checks.reputation.reputation.risk.toUpperCase()}
        </Badge>
      </div>

      {/* Domain Age */}
      {result.checks.reputation.reputation.age.ageInDays !== null && (
        <div className="flex justify-between items-center">
          <span>Domain Age:</span>
          <span className={
            result.checks.reputation.reputation.age.isNew ? 'text-red-600' :
            result.checks.reputation.reputation.age.isYoung ? 'text-yellow-600' :
            'text-green-600'
          }>
            {result.checks.reputation.reputation.age.message}
          </span>
        </div>
      )}

      {/* Blocklist Status */}
      <div className="flex justify-between items-center">
        <span>Blocklists:</span>
        <span className={result.checks.reputation.reputation.blocklists.listed ? 'text-red-600' : 'text-green-600'}>
          {result.checks.reputation.reputation.blocklists.message}
        </span>
      </div>

      {/* Risk Factors */}
      {result.checks.reputation.reputation.factors.length > 0 && (
        <div className="mt-2 space-y-1">
          <span className="text-muted-foreground">Risk Factors:</span>
          {result.checks.reputation.reputation.factors.map((factor, i) => (
            <div key={i} className={`flex items-center gap-2 text-xs ${
              factor.impact === 'positive' ? 'text-green-600' :
              factor.impact === 'negative' ? 'text-red-600' :
              'text-gray-600'
            }`}>
              {factor.impact === 'positive' ? '✓' : factor.impact === 'negative' ? '✗' : '•'}
              {factor.name}: {factor.description}
            </div>
          ))}
        </div>
      )}
    </div>
  </div>
)}
```

### Step 8: Write Tests

Create `src/__tests__/lib/reputation/reputation.test.ts`:

```typescript
import { checkDomainAge } from '@/lib/reputation/age';
import { checkBlocklists } from '@/lib/reputation/blocklist';

// Mock fetch
global.fetch = jest.fn();

describe('Domain Reputation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('Domain Age', () => {
    test('returns unknown age when RDAP fails', async () => {
      (fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

      const result = await checkDomainAge('example.com');

      expect(result.createdDate).toBeNull();
      expect(result.ageInDays).toBeNull();
      expect(result.message).toBe('Failed to check domain age');
    });

    test('calculates age correctly from RDAP response', async () => {
      const createdDate = new Date();
      createdDate.setDate(createdDate.getDate() - 100); // 100 days ago

      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          events: [
            { eventAction: 'registration', eventDate: createdDate.toISOString() }
          ]
        })
      });

      const result = await checkDomainAge('example.com');

      expect(result.ageInDays).toBeGreaterThanOrEqual(99);
      expect(result.ageInDays).toBeLessThanOrEqual(101);
      expect(result.isNew).toBe(false);
      expect(result.isYoung).toBe(true);
    });
  });

  describe('Blocklist Check', () => {
    test('detects suspicious TLD patterns', async () => {
      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ Answer: null })
      });

      const result = await checkBlocklists('spammydomain.xyz');

      const patternCheck = result.lists.find(l => l.name === 'Suspicious Pattern Detection');
      expect(patternCheck?.listed).toBe(true);
    });

    test('returns clean for normal domains', async () => {
      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ Answer: null })
      });

      const result = await checkBlocklists('google.com');

      expect(result.listed).toBe(false);
    });
  });
});
```

---

## Completion Checklist

```
[x] Reputation types defined
[x] Domain age checker implemented
[x] RDAP lookup for creation date
[x] Blocklist checker implemented
[x] DNS-based blocklist queries
[x] Suspicious pattern detection
[x] Reputation score calculation
[x] Risk factor analysis
[x] Caching implemented
[x] Validator created
[x] Main validator updated
[x] Types updated
[x] UI updated to show results
[x] Tests written and passing
[x] All existing tests pass
[x] Changes committed and pushed
```

---

## Next Milestone

After completing this milestone, proceed to:
`plans/milestones/7.4-gravatar-detection.md`
