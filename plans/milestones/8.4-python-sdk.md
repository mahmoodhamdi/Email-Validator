# Milestone 8.4: Python SDK

> **Phase:** 8 - API & Integrations
> **Status:** NOT STARTED
> **Priority:** MEDIUM
> **Complexity:** Medium
> **Estimated Time:** 4-5 hours

---

## Prompt for Claude Code

```
You are working on the Email Validator project. Your task is to create a Python SDK.

IMPORTANT INSTRUCTIONS:
1. Read this entire file before starting
2. Follow the implementation steps in order
3. Write comprehensive tests
4. Update the checklist as you complete each task
5. Commit with message: "feat: add Python SDK for email validation API"
6. Push the changes

PROJECT CONTEXT:
- Create SDK in packages/sdk-python/
- Use type hints throughout
- Support both sync and async
- Follow PEP 8 conventions
- Ready for PyPI publishing
```

---

## Objective

Create a Python SDK for the Email Validator API:
- Full type hint support
- Synchronous and asynchronous methods
- Automatic retries with exponential backoff
- Configurable timeouts
- Ready for PyPI publishing

---

## Implementation Steps

### Step 1: Create SDK Directory Structure

```
packages/
└── sdk-python/
    ├── email_validator_sdk/
    │   ├── __init__.py
    │   ├── client.py
    │   ├── async_client.py
    │   ├── types.py
    │   ├── exceptions.py
    │   └── utils.py
    ├── tests/
    │   ├── __init__.py
    │   ├── test_client.py
    │   └── test_async_client.py
    ├── pyproject.toml
    ├── setup.py
    ├── README.md
    └── .gitignore
```

### Step 2: Create Package Configuration

Create `packages/sdk-python/pyproject.toml`:

```toml
[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "email-validator-sdk"
version = "1.0.0"
description = "Python SDK for Email Validator API"
readme = "README.md"
license = {text = "MIT"}
requires-python = ">=3.8"
authors = [
    {name = "Your Name", email = "your.email@example.com"}
]
keywords = ["email", "validation", "validator", "sdk", "api"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Topic :: Communications :: Email",
    "Typing :: Typed",
]
dependencies = [
    "requests>=2.28.0",
    "aiohttp>=3.8.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",
    "pytest-cov>=4.0.0",
    "responses>=0.23.0",
    "aioresponses>=0.7.0",
    "mypy>=1.0.0",
    "black>=23.0.0",
    "isort>=5.0.0",
]

[project.urls]
Homepage = "https://github.com/your-username/email-validator"
Documentation = "https://github.com/your-username/email-validator#readme"
Repository = "https://github.com/your-username/email-validator"

[tool.setuptools.packages.find]
where = ["."]

[tool.black]
line-length = 100
target-version = ["py38"]

[tool.isort]
profile = "black"
line_length = 100

[tool.mypy]
python_version = "3.8"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
```

### Step 3: Create Types

Create `packages/sdk-python/email_validator_sdk/types.py`:

```python
"""Type definitions for Email Validator SDK."""

from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import List, Optional, Dict, Any


class Deliverability(str, Enum):
    """Email deliverability status."""
    DELIVERABLE = "deliverable"
    RISKY = "risky"
    UNDELIVERABLE = "undeliverable"
    UNKNOWN = "unknown"


class RiskLevel(str, Enum):
    """Email risk level."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


@dataclass
class SyntaxCheck:
    """Syntax validation result."""
    valid: bool
    local_part: Optional[str] = None
    domain: Optional[str] = None


@dataclass
class DomainCheck:
    """Domain validation result."""
    valid: bool
    exists: bool


@dataclass
class MXCheck:
    """MX record validation result."""
    valid: bool
    records: List[str]
    priority: Optional[List[int]] = None


@dataclass
class DisposableCheck:
    """Disposable email check result."""
    is_disposable: bool


@dataclass
class RoleBasedCheck:
    """Role-based email check result."""
    is_role_based: bool
    role: Optional[str] = None


@dataclass
class FreeProviderCheck:
    """Free provider check result."""
    is_free_provider: bool
    provider: Optional[str] = None


@dataclass
class TypoCheck:
    """Typo detection result."""
    has_typo: bool
    suggestion: Optional[str] = None


@dataclass
class SMTPCheck:
    """SMTP verification result."""
    checked: bool
    exists: Optional[bool]
    catch_all: bool
    message: str


@dataclass
class AuthenticationCheck:
    """Email authentication check result."""
    checked: bool
    score: int
    spf: Dict[str, Any]
    dmarc: Dict[str, Any]
    dkim: Dict[str, Any]


@dataclass
class ReputationCheck:
    """Domain reputation check result."""
    checked: bool
    score: int
    risk: str


@dataclass
class GravatarCheck:
    """Gravatar check result."""
    checked: bool
    exists: bool
    url: Optional[str] = None


@dataclass
class ValidationChecks:
    """All validation check results."""
    syntax: SyntaxCheck
    domain: DomainCheck
    mx: MXCheck
    disposable: DisposableCheck
    role_based: RoleBasedCheck
    free_provider: FreeProviderCheck
    typo: Optional[TypoCheck] = None
    smtp: Optional[SMTPCheck] = None
    authentication: Optional[AuthenticationCheck] = None
    reputation: Optional[ReputationCheck] = None
    gravatar: Optional[GravatarCheck] = None


@dataclass
class ValidationResult:
    """Email validation result."""
    email: str
    valid: bool
    score: int
    deliverability: Deliverability
    risk: RiskLevel
    checks: ValidationChecks
    suggestions: Optional[List[str]] = None
    validated_at: Optional[str] = None

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ValidationResult":
        """Create ValidationResult from API response dict."""
        checks_data = data.get("checks", {})

        checks = ValidationChecks(
            syntax=SyntaxCheck(**checks_data.get("syntax", {"valid": False})),
            domain=DomainCheck(**checks_data.get("domain", {"valid": False, "exists": False})),
            mx=MXCheck(**checks_data.get("mx", {"valid": False, "records": []})),
            disposable=DisposableCheck(
                is_disposable=checks_data.get("disposable", {}).get("isDisposable", False)
            ),
            role_based=RoleBasedCheck(
                is_role_based=checks_data.get("roleBased", {}).get("isRoleBased", False),
                role=checks_data.get("roleBased", {}).get("role"),
            ),
            free_provider=FreeProviderCheck(
                is_free_provider=checks_data.get("freeProvider", {}).get("isFreeProvider", False),
                provider=checks_data.get("freeProvider", {}).get("provider"),
            ),
        )

        return cls(
            email=data["email"],
            valid=data["valid"],
            score=data["score"],
            deliverability=Deliverability(data["deliverability"]),
            risk=RiskLevel(data["risk"]),
            checks=checks,
            suggestions=data.get("suggestions"),
            validated_at=data.get("validatedAt"),
        )


@dataclass
class BulkSummary:
    """Bulk validation summary."""
    total: int
    valid: int
    invalid: int
    risky: int
    unknown: int


@dataclass
class BulkValidationResult:
    """Bulk validation result."""
    results: List[ValidationResult]
    summary: BulkSummary
    processing_time: float

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BulkValidationResult":
        """Create BulkValidationResult from API response dict."""
        return cls(
            results=[ValidationResult.from_dict(r) for r in data["results"]],
            summary=BulkSummary(**data["summary"]),
            processing_time=data["processingTime"],
        )


@dataclass
class HealthCheckResult:
    """Health check result."""
    status: str
    version: str
    uptime: float
    timestamp: str


@dataclass
class ValidationOptions:
    """Options for email validation."""
    smtp_check: bool = False
    auth_check: bool = False
    reputation_check: bool = False
    gravatar_check: bool = False

    def to_dict(self) -> Dict[str, bool]:
        """Convert to API request dict."""
        return {
            "smtpCheck": self.smtp_check,
            "authCheck": self.auth_check,
            "reputationCheck": self.reputation_check,
            "gravatarCheck": self.gravatar_check,
        }
```

### Step 4: Create Exceptions

Create `packages/sdk-python/email_validator_sdk/exceptions.py`:

```python
"""Custom exceptions for Email Validator SDK."""

from typing import Any, Optional


class EmailValidatorError(Exception):
    """Base exception for Email Validator SDK."""

    def __init__(
        self,
        message: str,
        code: str = "UNKNOWN_ERROR",
        status_code: Optional[int] = None,
        details: Optional[Any] = None,
    ):
        super().__init__(message)
        self.message = message
        self.code = code
        self.status_code = status_code
        self.details = details


class ValidationError(EmailValidatorError):
    """Raised when input validation fails."""

    def __init__(self, message: str, details: Optional[Any] = None):
        super().__init__(message, "VALIDATION_ERROR", 400, details)


class AuthenticationError(EmailValidatorError):
    """Raised when API authentication fails."""

    def __init__(self, message: str = "Invalid or missing API key"):
        super().__init__(message, "AUTHENTICATION_ERROR", 401)


class RateLimitError(EmailValidatorError):
    """Raised when rate limit is exceeded."""

    def __init__(self, retry_after: Optional[int] = None):
        super().__init__("Rate limit exceeded", "RATE_LIMIT_ERROR", 429)
        self.retry_after = retry_after


class NetworkError(EmailValidatorError):
    """Raised when a network error occurs."""

    def __init__(self, message: str, cause: Optional[Exception] = None):
        super().__init__(message, "NETWORK_ERROR")
        self.cause = cause


class TimeoutError(EmailValidatorError):
    """Raised when request times out."""

    def __init__(self, timeout: float):
        super().__init__(f"Request timed out after {timeout}s", "TIMEOUT_ERROR")
        self.timeout = timeout
```

### Step 5: Create Utilities

Create `packages/sdk-python/email_validator_sdk/utils.py`:

```python
"""Utility functions for Email Validator SDK."""

import re
import random
import time
from typing import Optional


def get_backoff_delay(attempt: int, base_delay: float) -> float:
    """Calculate exponential backoff delay with jitter."""
    delay = base_delay * (2 ** attempt)
    jitter = random.uniform(0, 0.1)
    return delay + jitter


def is_retryable_status(status_code: Optional[int]) -> bool:
    """Check if HTTP status code is retryable."""
    if status_code is None:
        return True  # Network errors are retryable
    return status_code >= 500 or status_code == 429 or status_code == 408


def is_valid_email_format(email: str) -> bool:
    """Basic email format validation."""
    pattern = r"^[^\s@]+@[^\s@]+\.[^\s@]+$"
    return bool(re.match(pattern, email))


def sleep(seconds: float) -> None:
    """Sleep for specified seconds."""
    time.sleep(seconds)
```

### Step 6: Create Synchronous Client

Create `packages/sdk-python/email_validator_sdk/client.py`:

```python
"""Synchronous client for Email Validator API."""

import json
from typing import List, Optional, Dict, Any

import requests
from requests.exceptions import RequestException, Timeout

from .types import (
    ValidationResult,
    BulkValidationResult,
    HealthCheckResult,
    ValidationOptions,
)
from .exceptions import (
    EmailValidatorError,
    ValidationError,
    AuthenticationError,
    RateLimitError,
    NetworkError,
    TimeoutError,
)
from .utils import get_backoff_delay, is_retryable_status, is_valid_email_format, sleep


class EmailValidator:
    """Synchronous client for Email Validator API."""

    def __init__(
        self,
        base_url: str,
        api_key: Optional[str] = None,
        timeout: float = 30.0,
        max_retries: int = 3,
        retry_delay: float = 1.0,
    ):
        """
        Initialize Email Validator client.

        Args:
            base_url: Base URL of the Email Validator API
            api_key: Optional API key for authentication
            timeout: Request timeout in seconds
            max_retries: Maximum retry attempts
            retry_delay: Initial retry delay in seconds
        """
        self.base_url = base_url.rstrip("/")
        self.api_key = api_key
        self.timeout = timeout
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self._session = requests.Session()
        self._session.headers.update({
            "Content-Type": "application/json",
            "User-Agent": "EmailValidator-Python-SDK/1.0.0",
        })
        if api_key:
            self._session.headers["X-API-Key"] = api_key

    def validate(
        self,
        email: str,
        options: Optional[ValidationOptions] = None,
    ) -> ValidationResult:
        """
        Validate a single email address.

        Args:
            email: Email address to validate
            options: Optional validation options

        Returns:
            ValidationResult with validation details

        Raises:
            ValidationError: If email is invalid
            AuthenticationError: If API key is invalid
            RateLimitError: If rate limit is exceeded
            NetworkError: If network error occurs
            TimeoutError: If request times out
        """
        if not email or not isinstance(email, str):
            raise ValidationError("Email is required")

        if not is_valid_email_format(email):
            raise ValidationError("Invalid email format")

        payload: Dict[str, Any] = {"email": email}
        if options:
            payload.update(options.to_dict())

        response = self._request("POST", "/api/validate", json=payload)
        return ValidationResult.from_dict(response)

    def validate_bulk(
        self,
        emails: List[str],
        options: Optional[ValidationOptions] = None,
    ) -> BulkValidationResult:
        """
        Validate multiple email addresses.

        Args:
            emails: List of email addresses (max 1000)
            options: Optional validation options

        Returns:
            BulkValidationResult with all results

        Raises:
            ValidationError: If input is invalid
        """
        if not emails or not isinstance(emails, list):
            raise ValidationError("Emails list is required")

        if len(emails) == 0:
            raise ValidationError("Emails list cannot be empty")

        if len(emails) > 1000:
            raise ValidationError("Maximum 1000 emails per request")

        payload: Dict[str, Any] = {"emails": emails}
        if options:
            payload.update(options.to_dict())

        response = self._request("POST", "/api/validate-bulk", json=payload)
        return BulkValidationResult.from_dict(response)

    def health_check(self) -> HealthCheckResult:
        """
        Check API health status.

        Returns:
            HealthCheckResult with status details
        """
        response = self._request("GET", "/api/health")
        return HealthCheckResult(
            status=response["status"],
            version=response["version"],
            uptime=response["uptime"],
            timestamp=response["timestamp"],
        )

    def _request(
        self,
        method: str,
        endpoint: str,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Make HTTP request with retry logic."""
        url = f"{self.base_url}{endpoint}"
        last_error: Optional[Exception] = None

        for attempt in range(self.max_retries + 1):
            try:
                response = self._session.request(
                    method,
                    url,
                    timeout=self.timeout,
                    **kwargs,
                )

                if response.ok:
                    return response.json()

                # Handle specific error codes
                if response.status_code == 401:
                    raise AuthenticationError()

                if response.status_code == 429:
                    retry_after = response.headers.get("Retry-After")
                    raise RateLimitError(
                        retry_after=int(retry_after) if retry_after else None
                    )

                # Parse error response
                try:
                    error_data = response.json()
                except Exception:
                    error_data = response.text

                if not is_retryable_status(response.status_code):
                    raise EmailValidatorError(
                        f"API error: {response.status_code}",
                        "API_ERROR",
                        response.status_code,
                        error_data,
                    )

                last_error = EmailValidatorError(
                    f"API error: {response.status_code}",
                    "API_ERROR",
                    response.status_code,
                    error_data,
                )

            except Timeout:
                last_error = TimeoutError(self.timeout)
            except RequestException as e:
                last_error = NetworkError(str(e), e)
            except (AuthenticationError, RateLimitError):
                raise

            # Wait before retry (except on last attempt)
            if attempt < self.max_retries:
                delay = get_backoff_delay(attempt, self.retry_delay)
                sleep(delay)

        raise last_error or NetworkError("Request failed after retries")

    def close(self) -> None:
        """Close the HTTP session."""
        self._session.close()

    def __enter__(self) -> "EmailValidator":
        return self

    def __exit__(self, *args: Any) -> None:
        self.close()
```

### Step 7: Create Async Client

Create `packages/sdk-python/email_validator_sdk/async_client.py`:

```python
"""Asynchronous client for Email Validator API."""

import asyncio
from typing import List, Optional, Dict, Any

import aiohttp

from .types import (
    ValidationResult,
    BulkValidationResult,
    HealthCheckResult,
    ValidationOptions,
)
from .exceptions import (
    EmailValidatorError,
    ValidationError,
    AuthenticationError,
    RateLimitError,
    NetworkError,
    TimeoutError,
)
from .utils import get_backoff_delay, is_retryable_status, is_valid_email_format


class AsyncEmailValidator:
    """Asynchronous client for Email Validator API."""

    def __init__(
        self,
        base_url: str,
        api_key: Optional[str] = None,
        timeout: float = 30.0,
        max_retries: int = 3,
        retry_delay: float = 1.0,
    ):
        """
        Initialize async Email Validator client.

        Args:
            base_url: Base URL of the Email Validator API
            api_key: Optional API key for authentication
            timeout: Request timeout in seconds
            max_retries: Maximum retry attempts
            retry_delay: Initial retry delay in seconds
        """
        self.base_url = base_url.rstrip("/")
        self.api_key = api_key
        self.timeout = aiohttp.ClientTimeout(total=timeout)
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self._session: Optional[aiohttp.ClientSession] = None

    async def _get_session(self) -> aiohttp.ClientSession:
        """Get or create aiohttp session."""
        if self._session is None or self._session.closed:
            headers = {
                "Content-Type": "application/json",
                "User-Agent": "EmailValidator-Python-SDK/1.0.0",
            }
            if self.api_key:
                headers["X-API-Key"] = self.api_key
            self._session = aiohttp.ClientSession(
                headers=headers,
                timeout=self.timeout,
            )
        return self._session

    async def validate(
        self,
        email: str,
        options: Optional[ValidationOptions] = None,
    ) -> ValidationResult:
        """
        Validate a single email address asynchronously.

        Args:
            email: Email address to validate
            options: Optional validation options

        Returns:
            ValidationResult with validation details
        """
        if not email or not isinstance(email, str):
            raise ValidationError("Email is required")

        if not is_valid_email_format(email):
            raise ValidationError("Invalid email format")

        payload: Dict[str, Any] = {"email": email}
        if options:
            payload.update(options.to_dict())

        response = await self._request("POST", "/api/validate", json=payload)
        return ValidationResult.from_dict(response)

    async def validate_bulk(
        self,
        emails: List[str],
        options: Optional[ValidationOptions] = None,
    ) -> BulkValidationResult:
        """
        Validate multiple email addresses asynchronously.

        Args:
            emails: List of email addresses (max 1000)
            options: Optional validation options

        Returns:
            BulkValidationResult with all results
        """
        if not emails or not isinstance(emails, list):
            raise ValidationError("Emails list is required")

        if len(emails) == 0:
            raise ValidationError("Emails list cannot be empty")

        if len(emails) > 1000:
            raise ValidationError("Maximum 1000 emails per request")

        payload: Dict[str, Any] = {"emails": emails}
        if options:
            payload.update(options.to_dict())

        response = await self._request("POST", "/api/validate-bulk", json=payload)
        return BulkValidationResult.from_dict(response)

    async def health_check(self) -> HealthCheckResult:
        """
        Check API health status asynchronously.

        Returns:
            HealthCheckResult with status details
        """
        response = await self._request("GET", "/api/health")
        return HealthCheckResult(
            status=response["status"],
            version=response["version"],
            uptime=response["uptime"],
            timestamp=response["timestamp"],
        )

    async def _request(
        self,
        method: str,
        endpoint: str,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Make HTTP request with retry logic."""
        session = await self._get_session()
        url = f"{self.base_url}{endpoint}"
        last_error: Optional[Exception] = None

        for attempt in range(self.max_retries + 1):
            try:
                async with session.request(method, url, **kwargs) as response:
                    if response.ok:
                        return await response.json()

                    # Handle specific error codes
                    if response.status == 401:
                        raise AuthenticationError()

                    if response.status == 429:
                        retry_after = response.headers.get("Retry-After")
                        raise RateLimitError(
                            retry_after=int(retry_after) if retry_after else None
                        )

                    # Parse error response
                    try:
                        error_data = await response.json()
                    except Exception:
                        error_data = await response.text()

                    if not is_retryable_status(response.status):
                        raise EmailValidatorError(
                            f"API error: {response.status}",
                            "API_ERROR",
                            response.status,
                            error_data,
                        )

                    last_error = EmailValidatorError(
                        f"API error: {response.status}",
                        "API_ERROR",
                        response.status,
                        error_data,
                    )

            except asyncio.TimeoutError:
                last_error = TimeoutError(self.timeout.total or 30.0)
            except aiohttp.ClientError as e:
                last_error = NetworkError(str(e), e)
            except (AuthenticationError, RateLimitError):
                raise

            # Wait before retry (except on last attempt)
            if attempt < self.max_retries:
                delay = get_backoff_delay(attempt, self.retry_delay)
                await asyncio.sleep(delay)

        raise last_error or NetworkError("Request failed after retries")

    async def close(self) -> None:
        """Close the HTTP session."""
        if self._session and not self._session.closed:
            await self._session.close()

    async def __aenter__(self) -> "AsyncEmailValidator":
        return self

    async def __aexit__(self, *args: Any) -> None:
        await self.close()
```

### Step 8: Create Package Init

Create `packages/sdk-python/email_validator_sdk/__init__.py`:

```python
"""Email Validator SDK for Python."""

from .client import EmailValidator
from .async_client import AsyncEmailValidator
from .types import (
    ValidationResult,
    BulkValidationResult,
    HealthCheckResult,
    ValidationOptions,
    ValidationChecks,
    Deliverability,
    RiskLevel,
)
from .exceptions import (
    EmailValidatorError,
    ValidationError,
    AuthenticationError,
    RateLimitError,
    NetworkError,
    TimeoutError,
)

__version__ = "1.0.0"

__all__ = [
    # Clients
    "EmailValidator",
    "AsyncEmailValidator",
    # Types
    "ValidationResult",
    "BulkValidationResult",
    "HealthCheckResult",
    "ValidationOptions",
    "ValidationChecks",
    "Deliverability",
    "RiskLevel",
    # Exceptions
    "EmailValidatorError",
    "ValidationError",
    "AuthenticationError",
    "RateLimitError",
    "NetworkError",
    "TimeoutError",
]
```

### Step 9: Create README

Create `packages/sdk-python/README.md`:

```markdown
# email-validator-sdk

Official Python SDK for the Email Validator API.

## Installation

```bash
pip install email-validator-sdk
```

## Quick Start

### Synchronous Usage

```python
from email_validator_sdk import EmailValidator, ValidationOptions

# Initialize client
validator = EmailValidator(
    base_url="https://your-api.com",
    api_key="your-api-key",  # Optional
)

# Validate single email
result = validator.validate("test@example.com")
print(result.valid)  # True/False
print(result.score)  # 0-100

# Validate with options
result = validator.validate(
    "test@example.com",
    options=ValidationOptions(
        smtp_check=True,
        reputation_check=True,
    )
)

# Bulk validation
bulk_result = validator.validateBulk([
    "email1@example.com",
    "email2@example.com",
])
print(bulk_result.summary.valid)

# Health check
health = validator.health_check()
print(health.status)

# Use as context manager
with EmailValidator(base_url="https://api.com") as validator:
    result = validator.validate("test@example.com")
```

### Asynchronous Usage

```python
import asyncio
from email_validator_sdk import AsyncEmailValidator

async def main():
    async with AsyncEmailValidator(base_url="https://your-api.com") as validator:
        result = await validator.validate("test@example.com")
        print(result.valid)

asyncio.run(main())
```

## Configuration

```python
validator = EmailValidator(
    base_url="https://your-api.com",  # Required
    api_key="your-api-key",           # Optional
    timeout=30.0,                      # Request timeout (seconds)
    max_retries=3,                     # Retry attempts
    retry_delay=1.0,                   # Initial retry delay (seconds)
)
```

## Error Handling

```python
from email_validator_sdk import (
    EmailValidator,
    ValidationError,
    RateLimitError,
    NetworkError,
)

try:
    result = validator.validate("test@example.com")
except ValidationError as e:
    print(f"Invalid input: {e.message}")
except RateLimitError as e:
    print(f"Rate limited. Retry after: {e.retry_after}")
except NetworkError as e:
    print(f"Network error: {e.message}")
```

## License

MIT
```

### Step 10: Write Tests

Create `packages/sdk-python/tests/test_client.py`:

```python
"""Tests for synchronous client."""

import pytest
import responses

from email_validator_sdk import (
    EmailValidator,
    ValidationError,
    AuthenticationError,
    RateLimitError,
)


@pytest.fixture
def validator():
    return EmailValidator(
        base_url="http://localhost:3000",
        api_key="test-key",
        max_retries=0,
    )


class TestValidate:
    @responses.activate
    def test_validate_success(self, validator):
        responses.add(
            responses.POST,
            "http://localhost:3000/api/validate",
            json={
                "email": "test@example.com",
                "valid": True,
                "score": 95,
                "deliverability": "deliverable",
                "risk": "low",
                "checks": {
                    "syntax": {"valid": True},
                    "domain": {"valid": True, "exists": True},
                    "mx": {"valid": True, "records": ["mx.example.com"]},
                    "disposable": {"isDisposable": False},
                    "roleBased": {"isRoleBased": False},
                    "freeProvider": {"isFreeProvider": False},
                },
            },
            status=200,
        )

        result = validator.validate("test@example.com")

        assert result.valid is True
        assert result.score == 95

    def test_validate_empty_email(self, validator):
        with pytest.raises(ValidationError):
            validator.validate("")

    def test_validate_invalid_format(self, validator):
        with pytest.raises(ValidationError):
            validator.validate("not-an-email")

    @responses.activate
    def test_validate_unauthorized(self, validator):
        responses.add(
            responses.POST,
            "http://localhost:3000/api/validate",
            json={"error": "Unauthorized"},
            status=401,
        )

        with pytest.raises(AuthenticationError):
            validator.validate("test@example.com")

    @responses.activate
    def test_validate_rate_limited(self, validator):
        responses.add(
            responses.POST,
            "http://localhost:3000/api/validate",
            json={"error": "Rate limited"},
            status=429,
            headers={"Retry-After": "60"},
        )

        with pytest.raises(RateLimitError) as exc_info:
            validator.validate("test@example.com")

        assert exc_info.value.retry_after == 60


class TestValidateBulk:
    @responses.activate
    def test_bulk_validate_success(self, validator):
        responses.add(
            responses.POST,
            "http://localhost:3000/api/validate-bulk",
            json={
                "results": [],
                "summary": {
                    "total": 2,
                    "valid": 2,
                    "invalid": 0,
                    "risky": 0,
                    "unknown": 0,
                },
                "processingTime": 100,
            },
            status=200,
        )

        result = validator.validate_bulk(["a@b.com", "c@d.com"])

        assert result.summary.total == 2

    def test_bulk_validate_empty_list(self, validator):
        with pytest.raises(ValidationError):
            validator.validate_bulk([])

    def test_bulk_validate_too_many(self, validator):
        emails = ["test@example.com"] * 1001
        with pytest.raises(ValidationError):
            validator.validate_bulk(emails)


class TestHealthCheck:
    @responses.activate
    def test_health_check_success(self, validator):
        responses.add(
            responses.GET,
            "http://localhost:3000/api/health",
            json={
                "status": "healthy",
                "version": "1.0.0",
                "uptime": 12345,
                "timestamp": "2024-01-01T00:00:00Z",
            },
            status=200,
        )

        result = validator.health_check()

        assert result.status == "healthy"
```

---

## Completion Checklist

```
[ ] SDK directory structure created
[ ] pyproject.toml configured
[ ] Types with dataclasses
[ ] Exception classes created
[ ] Utility functions created
[ ] Synchronous client created
[ ] validate() method implemented
[ ] validate_bulk() method implemented
[ ] health_check() method implemented
[ ] Async client created
[ ] Async versions of all methods
[ ] Retry logic with backoff
[ ] Timeout handling
[ ] Context manager support
[ ] README documentation
[ ] Tests written and passing
[ ] PyPI publish ready
[ ] Changes committed and pushed
```

---

## Next Milestone

After completing this milestone, proceed to:
`plans/milestones/9.1-pwa-support.md`
