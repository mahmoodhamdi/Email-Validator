# Milestone 8.3: Node.js SDK

> **Phase:** 8 - API & Integrations
> **Status:** NOT STARTED
> **Priority:** MEDIUM
> **Complexity:** Medium
> **Estimated Time:** 4-5 hours

---

## Prompt for Claude Code

```
You are working on the Email Validator project. Your task is to create a Node.js SDK.

IMPORTANT INSTRUCTIONS:
1. Read this entire file before starting
2. Follow the implementation steps in order
3. Write comprehensive tests
4. Update the checklist as you complete each task
5. Commit with message: "feat: add Node.js SDK for email validation API"
6. Push the changes

PROJECT CONTEXT:
- Create SDK in packages/sdk-nodejs/
- Use TypeScript with full type exports
- Support CommonJS and ESM
- Include retry logic and error handling
```

---

## Objective

Create a Node.js SDK for the Email Validator API:
- Full TypeScript support
- All API methods (validate, bulk validate, health check)
- Automatic retries with exponential backoff
- Configurable timeouts
- Ready for npm publishing

---

## Implementation Steps

### Step 1: Create SDK Directory Structure

```
packages/
└── sdk-nodejs/
    ├── src/
    │   ├── index.ts
    │   ├── client.ts
    │   ├── types.ts
    │   ├── errors.ts
    │   └── utils.ts
    ├── tests/
    │   └── client.test.ts
    ├── package.json
    ├── tsconfig.json
    ├── README.md
    └── .npmignore
```

### Step 2: Create Package Configuration

Create `packages/sdk-nodejs/package.json`:

```json
{
  "name": "@email-validator/sdk",
  "version": "1.0.0",
  "description": "Node.js SDK for Email Validator API",
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "tsup src/index.ts --format cjs,esm --dts --clean",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint src --ext .ts",
    "prepublishOnly": "npm run build"
  },
  "keywords": [
    "email",
    "validation",
    "validator",
    "email-validator",
    "sdk"
  ],
  "author": "Your Name",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/your-username/email-validator"
  },
  "devDependencies": {
    "@types/jest": "^29.5.0",
    "@types/node": "^20.0.0",
    "jest": "^29.5.0",
    "ts-jest": "^29.1.0",
    "tsup": "^8.0.0",
    "typescript": "^5.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

Create `packages/sdk-nodejs/tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "declaration": true,
    "declarationMap": true,
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

### Step 3: Create Types

Create `packages/sdk-nodejs/src/types.ts`:

```typescript
export interface EmailValidatorConfig {
  /** Base URL of the Email Validator API */
  baseUrl: string;
  /** API key for authentication (optional) */
  apiKey?: string;
  /** Request timeout in milliseconds (default: 30000) */
  timeout?: number;
  /** Maximum retry attempts (default: 3) */
  maxRetries?: number;
  /** Initial retry delay in milliseconds (default: 1000) */
  retryDelay?: number;
}

export interface ValidationOptions {
  /** Enable SMTP verification (default: false) */
  smtpCheck?: boolean;
  /** Enable authentication checks (default: false) */
  authCheck?: boolean;
  /** Enable reputation check (default: false) */
  reputationCheck?: boolean;
  /** Enable Gravatar check (default: false) */
  gravatarCheck?: boolean;
}

export interface ValidationResult {
  email: string;
  valid: boolean;
  score: number;
  deliverability: 'deliverable' | 'risky' | 'undeliverable' | 'unknown';
  risk: 'low' | 'medium' | 'high';
  checks: ValidationChecks;
  suggestions?: string[];
  validatedAt: string;
}

export interface ValidationChecks {
  syntax: SyntaxCheck;
  domain: DomainCheck;
  mx: MXCheck;
  disposable: DisposableCheck;
  roleBased: RoleBasedCheck;
  freeProvider: FreeProviderCheck;
  typo?: TypoCheck;
  smtp?: SMTPCheck;
  authentication?: AuthenticationCheck;
  reputation?: ReputationCheck;
  gravatar?: GravatarCheck;
}

export interface SyntaxCheck {
  valid: boolean;
  localPart?: string;
  domain?: string;
}

export interface DomainCheck {
  valid: boolean;
  exists: boolean;
}

export interface MXCheck {
  valid: boolean;
  records: string[];
  priority?: number[];
}

export interface DisposableCheck {
  isDisposable: boolean;
}

export interface RoleBasedCheck {
  isRoleBased: boolean;
  role?: string;
}

export interface FreeProviderCheck {
  isFreeProvider: boolean;
  provider?: string;
}

export interface TypoCheck {
  hasTypo: boolean;
  suggestion?: string;
}

export interface SMTPCheck {
  checked: boolean;
  exists: boolean | null;
  catchAll: boolean;
  message: string;
}

export interface AuthenticationCheck {
  checked: boolean;
  score: number;
  spf: { exists: boolean; strength: string };
  dmarc: { exists: boolean; strength: string };
  dkim: { found: boolean; recordCount: number };
}

export interface ReputationCheck {
  checked: boolean;
  score: number;
  risk: string;
}

export interface GravatarCheck {
  checked: boolean;
  exists: boolean;
  url?: string;
}

export interface BulkValidationResult {
  results: ValidationResult[];
  summary: BulkSummary;
  processingTime: number;
}

export interface BulkSummary {
  total: number;
  valid: number;
  invalid: number;
  risky: number;
  unknown: number;
}

export interface HealthCheckResult {
  status: 'healthy' | 'unhealthy';
  version: string;
  uptime: number;
  timestamp: string;
}
```

### Step 4: Create Error Classes

Create `packages/sdk-nodejs/src/errors.ts`:

```typescript
export class EmailValidatorError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly statusCode?: number,
    public readonly details?: unknown
  ) {
    super(message);
    this.name = 'EmailValidatorError';
    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends EmailValidatorError {
  constructor(message: string, details?: unknown) {
    super(message, 'VALIDATION_ERROR', 400, details);
    this.name = 'ValidationError';
  }
}

export class AuthenticationError extends EmailValidatorError {
  constructor(message: string = 'Invalid or missing API key') {
    super(message, 'AUTHENTICATION_ERROR', 401);
    this.name = 'AuthenticationError';
  }
}

export class RateLimitError extends EmailValidatorError {
  constructor(
    public readonly retryAfter?: number
  ) {
    super('Rate limit exceeded', 'RATE_LIMIT_ERROR', 429);
    this.name = 'RateLimitError';
  }
}

export class NetworkError extends EmailValidatorError {
  constructor(message: string, public readonly cause?: Error) {
    super(message, 'NETWORK_ERROR');
    this.name = 'NetworkError';
  }
}

export class TimeoutError extends EmailValidatorError {
  constructor(timeout: number) {
    super(`Request timed out after ${timeout}ms`, 'TIMEOUT_ERROR');
    this.name = 'TimeoutError';
  }
}
```

### Step 5: Create Utilities

Create `packages/sdk-nodejs/src/utils.ts`:

```typescript
/**
 * Sleep for specified milliseconds
 */
export function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Calculate exponential backoff delay
 */
export function getBackoffDelay(attempt: number, baseDelay: number): number {
  return baseDelay * Math.pow(2, attempt) + Math.random() * 100;
}

/**
 * Check if error is retryable
 */
export function isRetryableError(statusCode?: number): boolean {
  if (!statusCode) return true; // Network errors are retryable
  return statusCode >= 500 || statusCode === 429 || statusCode === 408;
}

/**
 * Validate email format (basic)
 */
export function isValidEmailFormat(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}
```

### Step 6: Create Client

Create `packages/sdk-nodejs/src/client.ts`:

```typescript
import {
  EmailValidatorConfig,
  ValidationOptions,
  ValidationResult,
  BulkValidationResult,
  HealthCheckResult,
} from './types';
import {
  EmailValidatorError,
  ValidationError,
  AuthenticationError,
  RateLimitError,
  NetworkError,
  TimeoutError,
} from './errors';
import { sleep, getBackoffDelay, isRetryableError, isValidEmailFormat } from './utils';

const DEFAULT_CONFIG: Required<Omit<EmailValidatorConfig, 'apiKey'>> = {
  baseUrl: 'http://localhost:3000',
  timeout: 30000,
  maxRetries: 3,
  retryDelay: 1000,
};

export class EmailValidator {
  private readonly config: Required<Omit<EmailValidatorConfig, 'apiKey'>> & { apiKey?: string };

  constructor(config: EmailValidatorConfig) {
    this.config = {
      ...DEFAULT_CONFIG,
      ...config,
    };
  }

  /**
   * Validate a single email address
   */
  async validate(email: string, options?: ValidationOptions): Promise<ValidationResult> {
    if (!email || typeof email !== 'string') {
      throw new ValidationError('Email is required');
    }

    if (!isValidEmailFormat(email)) {
      throw new ValidationError('Invalid email format');
    }

    const response = await this.request<ValidationResult>('/api/validate', {
      method: 'POST',
      body: JSON.stringify({ email, ...options }),
    });

    return response;
  }

  /**
   * Validate multiple email addresses
   */
  async validateBulk(
    emails: string[],
    options?: ValidationOptions
  ): Promise<BulkValidationResult> {
    if (!emails || !Array.isArray(emails) || emails.length === 0) {
      throw new ValidationError('Emails array is required');
    }

    if (emails.length > 1000) {
      throw new ValidationError('Maximum 1000 emails per request');
    }

    const response = await this.request<BulkValidationResult>('/api/validate-bulk', {
      method: 'POST',
      body: JSON.stringify({ emails, ...options }),
    });

    return response;
  }

  /**
   * Check API health status
   */
  async healthCheck(): Promise<HealthCheckResult> {
    return this.request<HealthCheckResult>('/api/health', {
      method: 'GET',
    });
  }

  /**
   * Make HTTP request with retry logic
   */
  private async request<T>(
    endpoint: string,
    options: RequestInit
  ): Promise<T> {
    const url = `${this.config.baseUrl}${endpoint}`;
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'User-Agent': 'EmailValidator-NodeJS-SDK/1.0.0',
    };

    if (this.config.apiKey) {
      headers['X-API-Key'] = this.config.apiKey;
    }

    let lastError: Error | undefined;

    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

        const response = await fetch(url, {
          ...options,
          headers: { ...headers, ...options.headers },
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (response.ok) {
          return await response.json();
        }

        // Handle specific error codes
        if (response.status === 401) {
          throw new AuthenticationError();
        }

        if (response.status === 429) {
          const retryAfter = parseInt(response.headers.get('Retry-After') || '60', 10);
          throw new RateLimitError(retryAfter);
        }

        // Parse error response
        let errorDetails: unknown;
        try {
          errorDetails = await response.json();
        } catch {
          errorDetails = await response.text();
        }

        if (!isRetryableError(response.status)) {
          throw new EmailValidatorError(
            `API error: ${response.status}`,
            'API_ERROR',
            response.status,
            errorDetails
          );
        }

        lastError = new EmailValidatorError(
          `API error: ${response.status}`,
          'API_ERROR',
          response.status,
          errorDetails
        );

      } catch (error) {
        if (error instanceof EmailValidatorError) {
          if (!isRetryableError(error.statusCode)) {
            throw error;
          }
          lastError = error;
        } else if (error instanceof Error) {
          if (error.name === 'AbortError') {
            lastError = new TimeoutError(this.config.timeout);
          } else {
            lastError = new NetworkError(error.message, error);
          }
        }
      }

      // Wait before retry (except on last attempt)
      if (attempt < this.config.maxRetries) {
        const delay = getBackoffDelay(attempt, this.config.retryDelay);
        await sleep(delay);
      }
    }

    throw lastError || new NetworkError('Request failed after retries');
  }
}
```

### Step 7: Create Main Export

Create `packages/sdk-nodejs/src/index.ts`:

```typescript
export { EmailValidator } from './client';
export * from './types';
export * from './errors';
```

### Step 8: Create README

Create `packages/sdk-nodejs/README.md`:

```markdown
# @email-validator/sdk

Official Node.js SDK for the Email Validator API.

## Installation

```bash
npm install @email-validator/sdk
```

## Quick Start

```typescript
import { EmailValidator } from '@email-validator/sdk';

const validator = new EmailValidator({
  baseUrl: 'https://your-api.com',
  apiKey: 'your-api-key', // Optional
});

// Validate single email
const result = await validator.validate('test@example.com');
console.log(result.valid); // true/false
console.log(result.score); // 0-100

// Validate with options
const resultWithOptions = await validator.validate('test@example.com', {
  smtpCheck: true,
  reputationCheck: true,
});

// Bulk validation
const bulkResult = await validator.validateBulk([
  'email1@example.com',
  'email2@example.com',
]);
console.log(bulkResult.summary.valid);

// Health check
const health = await validator.healthCheck();
console.log(health.status);
```

## Configuration

```typescript
const validator = new EmailValidator({
  baseUrl: 'https://your-api.com', // Required
  apiKey: 'your-api-key',          // Optional
  timeout: 30000,                   // Request timeout (ms)
  maxRetries: 3,                    // Retry attempts
  retryDelay: 1000,                 // Initial retry delay (ms)
});
```

## API Reference

### `validate(email, options?)`

Validates a single email address.

**Parameters:**
- `email` (string): Email address to validate
- `options` (object, optional):
  - `smtpCheck` (boolean): Enable SMTP verification
  - `authCheck` (boolean): Enable authentication checks
  - `reputationCheck` (boolean): Enable reputation check
  - `gravatarCheck` (boolean): Enable Gravatar check

**Returns:** `Promise<ValidationResult>`

### `validateBulk(emails, options?)`

Validates multiple email addresses (max 1000).

**Parameters:**
- `emails` (string[]): Array of email addresses
- `options` (object, optional): Same as validate()

**Returns:** `Promise<BulkValidationResult>`

### `healthCheck()`

Checks API health status.

**Returns:** `Promise<HealthCheckResult>`

## Error Handling

```typescript
import {
  EmailValidator,
  ValidationError,
  RateLimitError,
  NetworkError
} from '@email-validator/sdk';

try {
  await validator.validate('test@example.com');
} catch (error) {
  if (error instanceof ValidationError) {
    console.log('Invalid input:', error.message);
  } else if (error instanceof RateLimitError) {
    console.log('Rate limited. Retry after:', error.retryAfter);
  } else if (error instanceof NetworkError) {
    console.log('Network error:', error.message);
  }
}
```

## TypeScript Support

Full TypeScript support with exported types:

```typescript
import type {
  ValidationResult,
  ValidationOptions,
  BulkValidationResult
} from '@email-validator/sdk';
```

## License

MIT
```

### Step 9: Write Tests

Create `packages/sdk-nodejs/tests/client.test.ts`:

```typescript
import { EmailValidator } from '../src/client';
import {
  ValidationError,
  AuthenticationError,
  RateLimitError,
  TimeoutError,
} from '../src/errors';

// Mock fetch
global.fetch = jest.fn();

describe('EmailValidator SDK', () => {
  let validator: EmailValidator;

  beforeEach(() => {
    validator = new EmailValidator({
      baseUrl: 'http://localhost:3000',
      apiKey: 'test-key',
      maxRetries: 0, // Disable retries for tests
    });
    jest.clearAllMocks();
  });

  describe('validate', () => {
    test('validates email successfully', async () => {
      const mockResult = {
        email: 'test@example.com',
        valid: true,
        score: 95,
        deliverability: 'deliverable',
        risk: 'low',
        checks: {},
      };

      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(mockResult),
      });

      const result = await validator.validate('test@example.com');

      expect(result.valid).toBe(true);
      expect(result.score).toBe(95);
    });

    test('throws ValidationError for empty email', async () => {
      await expect(validator.validate('')).rejects.toThrow(ValidationError);
    });

    test('throws ValidationError for invalid format', async () => {
      await expect(validator.validate('not-an-email')).rejects.toThrow(ValidationError);
    });

    test('includes API key in header', async () => {
      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ valid: true }),
      });

      await validator.validate('test@example.com');

      expect(fetch).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          headers: expect.objectContaining({
            'X-API-Key': 'test-key',
          }),
        })
      );
    });

    test('passes options to API', async () => {
      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({ valid: true }),
      });

      await validator.validate('test@example.com', {
        smtpCheck: true,
        reputationCheck: true,
      });

      const call = (fetch as jest.Mock).mock.calls[0];
      const body = JSON.parse(call[1].body);

      expect(body.smtpCheck).toBe(true);
      expect(body.reputationCheck).toBe(true);
    });
  });

  describe('validateBulk', () => {
    test('validates bulk emails successfully', async () => {
      const mockResult = {
        results: [],
        summary: { total: 2, valid: 2, invalid: 0, risky: 0, unknown: 0 },
        processingTime: 100,
      };

      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(mockResult),
      });

      const result = await validator.validateBulk(['a@b.com', 'c@d.com']);

      expect(result.summary.total).toBe(2);
    });

    test('throws ValidationError for empty array', async () => {
      await expect(validator.validateBulk([])).rejects.toThrow(ValidationError);
    });

    test('throws ValidationError for too many emails', async () => {
      const emails = Array(1001).fill('test@example.com');
      await expect(validator.validateBulk(emails)).rejects.toThrow(ValidationError);
    });
  });

  describe('healthCheck', () => {
    test('returns health status', async () => {
      const mockResult = {
        status: 'healthy',
        version: '1.0.0',
        uptime: 12345,
        timestamp: new Date().toISOString(),
      };

      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(mockResult),
      });

      const result = await validator.healthCheck();

      expect(result.status).toBe('healthy');
    });
  });

  describe('error handling', () => {
    test('throws AuthenticationError on 401', async () => {
      (fetch as jest.Mock).mockResolvedValue({
        ok: false,
        status: 401,
        json: () => Promise.resolve({ error: 'Unauthorized' }),
      });

      await expect(validator.validate('test@example.com'))
        .rejects.toThrow(AuthenticationError);
    });

    test('throws RateLimitError on 429', async () => {
      (fetch as jest.Mock).mockResolvedValue({
        ok: false,
        status: 429,
        headers: new Map([['Retry-After', '60']]),
        json: () => Promise.resolve({ error: 'Rate limited' }),
      });

      await expect(validator.validate('test@example.com'))
        .rejects.toThrow(RateLimitError);
    });
  });

  describe('retry logic', () => {
    test('retries on 500 error', async () => {
      const validatorWithRetry = new EmailValidator({
        baseUrl: 'http://localhost:3000',
        maxRetries: 2,
        retryDelay: 10, // Short delay for tests
      });

      (fetch as jest.Mock)
        .mockResolvedValueOnce({ ok: false, status: 500 })
        .mockResolvedValueOnce({ ok: false, status: 500 })
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({ valid: true }),
        });

      const result = await validatorWithRetry.validate('test@example.com');

      expect(result.valid).toBe(true);
      expect(fetch).toHaveBeenCalledTimes(3);
    });
  });
});
```

Create `packages/sdk-nodejs/jest.config.js`:

```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/tests'],
  testMatch: ['**/*.test.ts'],
  moduleFileExtensions: ['ts', 'js'],
};
```

### Step 10: Create .npmignore

Create `packages/sdk-nodejs/.npmignore`:

```
src/
tests/
tsconfig.json
jest.config.js
.eslintrc.js
*.test.ts
```

---

## Completion Checklist

```
[ ] SDK directory structure created
[ ] Package.json configured
[ ] TypeScript configuration
[ ] Types exported
[ ] Error classes created
[ ] Utility functions created
[ ] EmailValidator client created
[ ] validate() method implemented
[ ] validateBulk() method implemented
[ ] healthCheck() method implemented
[ ] Retry logic with backoff
[ ] Timeout handling
[ ] API key authentication
[ ] README documentation
[ ] Tests written and passing
[ ] Build script working
[ ] npm publish ready
[ ] Changes committed and pushed
```

---

## Next Milestone

After completing this milestone, proceed to:
`plans/milestones/8.4-python-sdk.md`
