# Milestone 9.4: Email List Cleaning

> **Phase:** 9 - User Experience
> **Status:** NOT STARTED
> **Priority:** LOW
> **Complexity:** Low
> **Estimated Time:** 2-3 hours

---

## Prompt for Claude Code

```
You are working on the Email Validator project. Your task is to implement email list cleaning features.

IMPORTANT INSTRUCTIONS:
1. Read this entire file before starting
2. Follow the implementation steps in order
3. Write comprehensive tests
4. Update the checklist as you complete each task
5. Commit with message: "feat: add email list cleaning and deduplication"
6. Push the changes

PROJECT CONTEXT:
- This is a Next.js 14 application
- Bulk validation already exists at /bulk
- Add cleaning features to enhance bulk validation
```

---

## Objective

Implement email list cleaning utilities:
- Remove duplicate emails
- Normalize email formats
- Detect and fix common issues
- Preview changes before applying
- Merge multiple lists
- Export cleaned lists

---

## Implementation Steps

### Step 1: Create List Cleaning Types

Create `src/lib/cleaning/types.ts`:

```typescript
export interface CleaningOptions {
  removeDuplicates: boolean;
  normalizeCase: boolean;
  trimWhitespace: boolean;
  removeInvalidSyntax: boolean;
  removeEmpty: boolean;
  sortAlphabetically: boolean;
  groupByDomain: boolean;
}

export interface CleaningResult {
  original: string[];
  cleaned: string[];
  changes: CleaningChange[];
  stats: CleaningStats;
}

export interface CleaningChange {
  type: CleaningChangeType;
  original?: string;
  cleaned?: string;
  count?: number;
}

export type CleaningChangeType =
  | 'duplicate_removed'
  | 'normalized'
  | 'trimmed'
  | 'invalid_removed'
  | 'empty_removed'
  | 'sorted'
  | 'merged';

export interface CleaningStats {
  originalCount: number;
  cleanedCount: number;
  duplicatesRemoved: number;
  normalized: number;
  invalidRemoved: number;
  emptyRemoved: number;
}

export interface MergeResult {
  merged: string[];
  stats: {
    totalOriginal: number;
    totalMerged: number;
    duplicatesRemoved: number;
    listsCount: number;
  };
}
```

### Step 2: Create List Cleaning Functions

Create `src/lib/cleaning/cleaner.ts`:

```typescript
import {
  CleaningOptions,
  CleaningResult,
  CleaningChange,
  CleaningStats,
  MergeResult,
} from './types';

const DEFAULT_OPTIONS: CleaningOptions = {
  removeDuplicates: true,
  normalizeCase: true,
  trimWhitespace: true,
  removeInvalidSyntax: true,
  removeEmpty: true,
  sortAlphabetically: false,
  groupByDomain: false,
};

const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

/**
 * Clean a list of emails according to options
 */
export function cleanEmailList(
  emails: string[],
  options: Partial<CleaningOptions> = {}
): CleaningResult {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const changes: CleaningChange[] = [];
  let cleaned = [...emails];
  let stats: CleaningStats = {
    originalCount: emails.length,
    cleanedCount: 0,
    duplicatesRemoved: 0,
    normalized: 0,
    invalidRemoved: 0,
    emptyRemoved: 0,
  };

  // Remove empty entries
  if (opts.removeEmpty) {
    const beforeCount = cleaned.length;
    cleaned = cleaned.filter((email) => email && email.trim().length > 0);
    stats.emptyRemoved = beforeCount - cleaned.length;
    if (stats.emptyRemoved > 0) {
      changes.push({
        type: 'empty_removed',
        count: stats.emptyRemoved,
      });
    }
  }

  // Trim whitespace
  if (opts.trimWhitespace) {
    cleaned = cleaned.map((email) => {
      const trimmed = email.trim();
      if (trimmed !== email) {
        changes.push({
          type: 'trimmed',
          original: email,
          cleaned: trimmed,
        });
      }
      return trimmed;
    });
  }

  // Normalize case (lowercase)
  if (opts.normalizeCase) {
    cleaned = cleaned.map((email) => {
      const normalized = email.toLowerCase();
      if (normalized !== email) {
        stats.normalized++;
        changes.push({
          type: 'normalized',
          original: email,
          cleaned: normalized,
        });
      }
      return normalized;
    });
  }

  // Remove invalid syntax
  if (opts.removeInvalidSyntax) {
    const beforeCount = cleaned.length;
    cleaned = cleaned.filter((email) => EMAIL_REGEX.test(email));
    stats.invalidRemoved = beforeCount - cleaned.length;
    if (stats.invalidRemoved > 0) {
      changes.push({
        type: 'invalid_removed',
        count: stats.invalidRemoved,
      });
    }
  }

  // Remove duplicates
  if (opts.removeDuplicates) {
    const beforeCount = cleaned.length;
    const seen = new Set<string>();
    cleaned = cleaned.filter((email) => {
      if (seen.has(email)) {
        return false;
      }
      seen.add(email);
      return true;
    });
    stats.duplicatesRemoved = beforeCount - cleaned.length;
    if (stats.duplicatesRemoved > 0) {
      changes.push({
        type: 'duplicate_removed',
        count: stats.duplicatesRemoved,
      });
    }
  }

  // Sort alphabetically
  if (opts.sortAlphabetically) {
    cleaned.sort((a, b) => a.localeCompare(b));
    changes.push({ type: 'sorted' });
  }

  // Group by domain
  if (opts.groupByDomain) {
    cleaned.sort((a, b) => {
      const domainA = a.split('@')[1] || '';
      const domainB = b.split('@')[1] || '';
      return domainA.localeCompare(domainB) || a.localeCompare(b);
    });
  }

  stats.cleanedCount = cleaned.length;

  return {
    original: emails,
    cleaned,
    changes,
    stats,
  };
}

/**
 * Merge multiple email lists
 */
export function mergeEmailLists(
  lists: string[][],
  options: Partial<CleaningOptions> = {}
): MergeResult {
  const allEmails = lists.flat();
  const totalOriginal = allEmails.length;

  // Clean the merged list
  const cleaned = cleanEmailList(allEmails, {
    ...options,
    removeDuplicates: true,
  });

  return {
    merged: cleaned.cleaned,
    stats: {
      totalOriginal,
      totalMerged: cleaned.stats.cleanedCount,
      duplicatesRemoved: cleaned.stats.duplicatesRemoved,
      listsCount: lists.length,
    },
  };
}

/**
 * Find duplicates in a list
 */
export function findDuplicates(emails: string[]): Map<string, number> {
  const counts = new Map<string, number>();
  const normalized = emails.map((e) => e.toLowerCase().trim());

  normalized.forEach((email) => {
    counts.set(email, (counts.get(email) || 0) + 1);
  });

  // Filter to only duplicates
  const duplicates = new Map<string, number>();
  counts.forEach((count, email) => {
    if (count > 1) {
      duplicates.set(email, count);
    }
  });

  return duplicates;
}

/**
 * Group emails by domain
 */
export function groupByDomain(emails: string[]): Map<string, string[]> {
  const groups = new Map<string, string[]>();

  emails.forEach((email) => {
    const domain = email.split('@')[1]?.toLowerCase() || 'unknown';
    if (!groups.has(domain)) {
      groups.set(domain, []);
    }
    groups.get(domain)!.push(email);
  });

  return groups;
}

/**
 * Validate email syntax
 */
export function isValidEmailSyntax(email: string): boolean {
  return EMAIL_REGEX.test(email.trim());
}
```

### Step 3: Create List Cleaning Index

Create `src/lib/cleaning/index.ts`:

```typescript
export {
  cleanEmailList,
  mergeEmailLists,
  findDuplicates,
  groupByDomain,
  isValidEmailSyntax,
} from './cleaner';
export * from './types';
```

### Step 4: Create List Cleaning Component

Create `src/components/cleaning/ListCleaner.tsx`:

```typescript
'use client';

import { useState, useMemo } from 'react';
import {
  cleanEmailList,
  findDuplicates,
  groupByDomain,
  CleaningOptions,
  CleaningResult,
} from '@/lib/cleaning';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Checkbox } from '@/components/ui/checkbox';
import { Badge } from '@/components/ui/badge';
import { Textarea } from '@/components/ui/textarea';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import {
  Trash2,
  Copy,
  Download,
  ArrowRight,
  Wand2,
  AlertCircle,
} from 'lucide-react';

interface ListCleanerProps {
  initialEmails?: string[];
  onCleaned?: (emails: string[]) => void;
}

export function ListCleaner({ initialEmails = [], onCleaned }: ListCleanerProps) {
  const [input, setInput] = useState(initialEmails.join('\n'));
  const [options, setOptions] = useState<CleaningOptions>({
    removeDuplicates: true,
    normalizeCase: true,
    trimWhitespace: true,
    removeInvalidSyntax: true,
    removeEmpty: true,
    sortAlphabetically: false,
    groupByDomain: false,
  });
  const [result, setResult] = useState<CleaningResult | null>(null);
  const [activeTab, setActiveTab] = useState('preview');

  const emails = useMemo(() => {
    return input
      .split('\n')
      .map((e) => e.trim())
      .filter(Boolean);
  }, [input]);

  const duplicates = useMemo(() => findDuplicates(emails), [emails]);
  const domainGroups = useMemo(() => groupByDomain(emails), [emails]);

  const handleClean = () => {
    const cleanResult = cleanEmailList(emails, options);
    setResult(cleanResult);
    setActiveTab('result');
  };

  const handleApply = () => {
    if (result) {
      setInput(result.cleaned.join('\n'));
      onCleaned?.(result.cleaned);
      setResult(null);
      setActiveTab('preview');
    }
  };

  const handleCopy = () => {
    const textToCopy = result ? result.cleaned.join('\n') : input;
    navigator.clipboard.writeText(textToCopy);
  };

  const handleDownload = () => {
    const textToDownload = result ? result.cleaned.join('\n') : input;
    const blob = new Blob([textToDownload], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'cleaned-emails.txt';
    a.click();
    URL.revokeObjectURL(url);
  };

  return (
    <div className="space-y-4">
      {/* Input */}
      <Card>
        <CardHeader>
          <CardTitle>Email List</CardTitle>
        </CardHeader>
        <CardContent>
          <Textarea
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Paste emails here (one per line)"
            rows={10}
            className="font-mono text-sm"
          />
          <div className="flex justify-between items-center mt-2 text-sm text-muted-foreground">
            <span>{emails.length} emails</span>
            {duplicates.size > 0 && (
              <Badge variant="destructive">
                {duplicates.size} duplicates found
              </Badge>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Options */}
      <Card>
        <CardHeader>
          <CardTitle>Cleaning Options</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
            {Object.entries(options).map(([key, value]) => (
              <label key={key} className="flex items-center gap-2 cursor-pointer">
                <Checkbox
                  checked={value}
                  onCheckedChange={(checked) =>
                    setOptions((prev) => ({ ...prev, [key]: checked }))
                  }
                />
                <span className="text-sm">
                  {key.replace(/([A-Z])/g, ' $1').trim()}
                </span>
              </label>
            ))}
          </div>

          <Button onClick={handleClean} className="mt-4">
            <Wand2 className="h-4 w-4 mr-2" />
            Clean List
          </Button>
        </CardContent>
      </Card>

      {/* Results */}
      {result && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center justify-between">
              <span>Results</span>
              <div className="flex gap-2">
                <Button variant="outline" size="sm" onClick={handleCopy}>
                  <Copy className="h-4 w-4 mr-2" />
                  Copy
                </Button>
                <Button variant="outline" size="sm" onClick={handleDownload}>
                  <Download className="h-4 w-4 mr-2" />
                  Download
                </Button>
                <Button size="sm" onClick={handleApply}>
                  Apply Changes
                </Button>
              </div>
            </CardTitle>
          </CardHeader>
          <CardContent>
            {/* Stats */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
              <div className="text-center p-3 bg-muted rounded-lg">
                <div className="text-2xl font-bold">{result.stats.originalCount}</div>
                <div className="text-xs text-muted-foreground">Original</div>
              </div>
              <div className="text-center p-3 bg-muted rounded-lg">
                <div className="text-2xl font-bold text-green-600">
                  {result.stats.cleanedCount}
                </div>
                <div className="text-xs text-muted-foreground">After Cleaning</div>
              </div>
              <div className="text-center p-3 bg-muted rounded-lg">
                <div className="text-2xl font-bold text-red-600">
                  {result.stats.duplicatesRemoved}
                </div>
                <div className="text-xs text-muted-foreground">Duplicates Removed</div>
              </div>
              <div className="text-center p-3 bg-muted rounded-lg">
                <div className="text-2xl font-bold text-yellow-600">
                  {result.stats.invalidRemoved}
                </div>
                <div className="text-xs text-muted-foreground">Invalid Removed</div>
              </div>
            </div>

            <Tabs value={activeTab} onValueChange={setActiveTab}>
              <TabsList>
                <TabsTrigger value="preview">Preview</TabsTrigger>
                <TabsTrigger value="changes">Changes ({result.changes.length})</TabsTrigger>
                <TabsTrigger value="domains">By Domain</TabsTrigger>
              </TabsList>

              <TabsContent value="preview" className="mt-4">
                <Textarea
                  value={result.cleaned.join('\n')}
                  readOnly
                  rows={10}
                  className="font-mono text-sm"
                />
              </TabsContent>

              <TabsContent value="changes" className="mt-4">
                <div className="max-h-64 overflow-y-auto space-y-2">
                  {result.changes.map((change, i) => (
                    <div
                      key={i}
                      className="flex items-center gap-2 text-sm p-2 bg-muted rounded"
                    >
                      <Badge variant="outline">{change.type}</Badge>
                      {change.original && change.cleaned && (
                        <>
                          <span className="line-through text-muted-foreground">
                            {change.original}
                          </span>
                          <ArrowRight className="h-3 w-3" />
                          <span className="text-green-600">{change.cleaned}</span>
                        </>
                      )}
                      {change.count && (
                        <span className="text-muted-foreground">
                          ({change.count} items)
                        </span>
                      )}
                    </div>
                  ))}
                </div>
              </TabsContent>

              <TabsContent value="domains" className="mt-4">
                <div className="space-y-2 max-h-64 overflow-y-auto">
                  {Array.from(groupByDomain(result.cleaned)).map(([domain, domainEmails]) => (
                    <div key={domain} className="p-2 bg-muted rounded">
                      <div className="flex items-center justify-between">
                        <span className="font-medium">{domain}</span>
                        <Badge>{domainEmails.length}</Badge>
                      </div>
                    </div>
                  ))}
                </div>
              </TabsContent>
            </Tabs>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
```

### Step 5: Create List Merge Component

Create `src/components/cleaning/ListMerger.tsx`:

```typescript
'use client';

import { useState } from 'react';
import { mergeEmailLists, MergeResult } from '@/lib/cleaning';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Textarea } from '@/components/ui/textarea';
import { Badge } from '@/components/ui/badge';
import { Plus, Trash2, Merge, Download, Copy } from 'lucide-react';

export function ListMerger() {
  const [lists, setLists] = useState<string[]>(['', '']);
  const [result, setResult] = useState<MergeResult | null>(null);

  const addList = () => {
    setLists((prev) => [...prev, '']);
  };

  const removeList = (index: number) => {
    if (lists.length > 2) {
      setLists((prev) => prev.filter((_, i) => i !== index));
    }
  };

  const updateList = (index: number, value: string) => {
    setLists((prev) => prev.map((list, i) => (i === index ? value : list)));
  };

  const handleMerge = () => {
    const parsedLists = lists.map((list) =>
      list
        .split('\n')
        .map((e) => e.trim())
        .filter(Boolean)
    );

    const mergeResult = mergeEmailLists(parsedLists);
    setResult(mergeResult);
  };

  const handleCopy = () => {
    if (result) {
      navigator.clipboard.writeText(result.merged.join('\n'));
    }
  };

  const handleDownload = () => {
    if (result) {
      const blob = new Blob([result.merged.join('\n')], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'merged-emails.txt';
      a.click();
      URL.revokeObjectURL(url);
    }
  };

  return (
    <div className="space-y-4">
      {/* Input Lists */}
      {lists.map((list, index) => (
        <Card key={index}>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">List {index + 1}</CardTitle>
            {lists.length > 2 && (
              <Button
                variant="ghost"
                size="icon"
                onClick={() => removeList(index)}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            )}
          </CardHeader>
          <CardContent>
            <Textarea
              value={list}
              onChange={(e) => updateList(index, e.target.value)}
              placeholder="Paste emails (one per line)"
              rows={5}
              className="font-mono text-sm"
            />
            <div className="text-xs text-muted-foreground mt-1">
              {list.split('\n').filter((e) => e.trim()).length} emails
            </div>
          </CardContent>
        </Card>
      ))}

      {/* Actions */}
      <div className="flex gap-2">
        <Button variant="outline" onClick={addList}>
          <Plus className="h-4 w-4 mr-2" />
          Add List
        </Button>
        <Button onClick={handleMerge}>
          <Merge className="h-4 w-4 mr-2" />
          Merge Lists
        </Button>
      </div>

      {/* Result */}
      {result && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center justify-between">
              <span>Merged Result</span>
              <div className="flex gap-2">
                <Button variant="outline" size="sm" onClick={handleCopy}>
                  <Copy className="h-4 w-4 mr-2" />
                  Copy
                </Button>
                <Button variant="outline" size="sm" onClick={handleDownload}>
                  <Download className="h-4 w-4 mr-2" />
                  Download
                </Button>
              </div>
            </CardTitle>
          </CardHeader>
          <CardContent>
            {/* Stats */}
            <div className="flex gap-4 mb-4">
              <Badge variant="outline">
                {result.stats.listsCount} lists merged
              </Badge>
              <Badge variant="outline">
                {result.stats.totalOriginal} original
              </Badge>
              <Badge variant="secondary">
                {result.stats.totalMerged} unique
              </Badge>
              <Badge variant="destructive">
                {result.stats.duplicatesRemoved} duplicates removed
              </Badge>
            </div>

            <Textarea
              value={result.merged.join('\n')}
              readOnly
              rows={10}
              className="font-mono text-sm"
            />
          </CardContent>
        </Card>
      )}
    </div>
  );
}
```

### Step 6: Create Cleaning Page

Create `src/app/tools/clean/page.tsx`:

```typescript
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { ListCleaner } from '@/components/cleaning/ListCleaner';
import { ListMerger } from '@/components/cleaning/ListMerger';
import { Wand2, Merge } from 'lucide-react';

export const metadata = {
  title: 'Email List Cleaning | Email Validator',
  description: 'Clean, deduplicate, and merge email lists',
};

export default function CleanPage() {
  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold">Email List Cleaning</h1>
        <p className="text-muted-foreground mt-2">
          Clean, deduplicate, and merge your email lists
        </p>
      </div>

      <Tabs defaultValue="clean" className="space-y-4">
        <TabsList>
          <TabsTrigger value="clean" className="flex items-center gap-2">
            <Wand2 className="h-4 w-4" />
            Clean List
          </TabsTrigger>
          <TabsTrigger value="merge" className="flex items-center gap-2">
            <Merge className="h-4 w-4" />
            Merge Lists
          </TabsTrigger>
        </TabsList>

        <TabsContent value="clean">
          <ListCleaner />
        </TabsContent>

        <TabsContent value="merge">
          <ListMerger />
        </TabsContent>
      </Tabs>
    </div>
  );
}
```

### Step 7: Write Tests

Create `src/__tests__/lib/cleaning/cleaning.test.ts`:

```typescript
import {
  cleanEmailList,
  mergeEmailLists,
  findDuplicates,
  groupByDomain,
  isValidEmailSyntax,
} from '@/lib/cleaning';

describe('Email List Cleaning', () => {
  describe('cleanEmailList', () => {
    test('removes duplicates', () => {
      const emails = ['test@example.com', 'test@example.com', 'other@example.com'];
      const result = cleanEmailList(emails, { removeDuplicates: true });

      expect(result.cleaned).toHaveLength(2);
      expect(result.stats.duplicatesRemoved).toBe(1);
    });

    test('normalizes case', () => {
      const emails = ['TEST@EXAMPLE.COM', 'Test@Example.Com'];
      const result = cleanEmailList(emails, { normalizeCase: true });

      expect(result.cleaned).toEqual(['test@example.com', 'test@example.com']);
    });

    test('removes invalid syntax', () => {
      const emails = ['valid@example.com', 'invalid', '@nodomain.com', 'noat.com'];
      const result = cleanEmailList(emails, { removeInvalidSyntax: true });

      expect(result.cleaned).toEqual(['valid@example.com']);
      expect(result.stats.invalidRemoved).toBe(3);
    });

    test('removes empty entries', () => {
      const emails = ['test@example.com', '', '  ', 'other@example.com'];
      const result = cleanEmailList(emails, { removeEmpty: true });

      expect(result.cleaned).toEqual(['test@example.com', 'other@example.com']);
      expect(result.stats.emptyRemoved).toBe(2);
    });

    test('trims whitespace', () => {
      const emails = ['  test@example.com  ', '\tother@example.com\t'];
      const result = cleanEmailList(emails, { trimWhitespace: true });

      expect(result.cleaned).toEqual(['test@example.com', 'other@example.com']);
    });

    test('sorts alphabetically', () => {
      const emails = ['z@example.com', 'a@example.com', 'm@example.com'];
      const result = cleanEmailList(emails, { sortAlphabetically: true });

      expect(result.cleaned).toEqual(['a@example.com', 'm@example.com', 'z@example.com']);
    });
  });

  describe('mergeEmailLists', () => {
    test('merges multiple lists', () => {
      const lists = [
        ['a@example.com', 'b@example.com'],
        ['c@example.com', 'd@example.com'],
      ];

      const result = mergeEmailLists(lists);

      expect(result.merged).toHaveLength(4);
      expect(result.stats.listsCount).toBe(2);
    });

    test('removes duplicates across lists', () => {
      const lists = [
        ['a@example.com', 'b@example.com'],
        ['b@example.com', 'c@example.com'],
      ];

      const result = mergeEmailLists(lists);

      expect(result.merged).toHaveLength(3);
      expect(result.stats.duplicatesRemoved).toBe(1);
    });
  });

  describe('findDuplicates', () => {
    test('finds duplicate emails', () => {
      const emails = ['a@test.com', 'b@test.com', 'a@test.com', 'a@test.com'];
      const duplicates = findDuplicates(emails);

      expect(duplicates.get('a@test.com')).toBe(3);
      expect(duplicates.has('b@test.com')).toBe(false);
    });

    test('handles case insensitivity', () => {
      const emails = ['TEST@example.com', 'test@example.com'];
      const duplicates = findDuplicates(emails);

      expect(duplicates.get('test@example.com')).toBe(2);
    });
  });

  describe('groupByDomain', () => {
    test('groups emails by domain', () => {
      const emails = ['a@gmail.com', 'b@yahoo.com', 'c@gmail.com'];
      const groups = groupByDomain(emails);

      expect(groups.get('gmail.com')).toHaveLength(2);
      expect(groups.get('yahoo.com')).toHaveLength(1);
    });
  });

  describe('isValidEmailSyntax', () => {
    test('validates correct emails', () => {
      expect(isValidEmailSyntax('test@example.com')).toBe(true);
      expect(isValidEmailSyntax('user.name@domain.co.uk')).toBe(true);
    });

    test('rejects invalid emails', () => {
      expect(isValidEmailSyntax('invalid')).toBe(false);
      expect(isValidEmailSyntax('@nodomain.com')).toBe(false);
      expect(isValidEmailSyntax('noat.com')).toBe(false);
    });
  });
});
```

---

## Completion Checklist

```
[ ] Cleaning types defined
[ ] cleanEmailList function
[ ] mergeEmailLists function
[ ] findDuplicates function
[ ] groupByDomain function
[ ] isValidEmailSyntax function
[ ] ListCleaner component
[ ] ListMerger component
[ ] Cleaning options UI
[ ] Preview changes feature
[ ] Stats display
[ ] Domain grouping view
[ ] Copy to clipboard
[ ] Download as file
[ ] Cleaning page created
[ ] Navigation updated
[ ] Tests written and passing
[ ] All existing tests pass
[ ] Changes committed and pushed
```

---

## Next Milestone

After completing this milestone, proceed to:
`plans/milestones/9.5-google-contacts.md`
