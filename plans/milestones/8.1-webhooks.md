# Milestone 8.1: Webhook Notifications

> **Phase:** 8 - API & Integrations
> **Status:** NOT STARTED
> **Priority:** MEDIUM
> **Complexity:** Medium
> **Estimated Time:** 4-5 hours

---

## Prompt for Claude Code

```
You are working on the Email Validator project. Your task is to implement webhook notifications.

IMPORTANT INSTRUCTIONS:
1. Read this entire file before starting
2. Follow the implementation steps in order
3. Write comprehensive tests
4. Update the checklist as you complete each task
5. Commit with message: "feat: add webhook notifications for validation events"
6. Push the changes

PROJECT CONTEXT:
- API routes at src/app/api/
- State management with Zustand
- localStorage for persistence
- Implement HMAC signature verification
```

---

## Objective

Implement webhook notifications to notify external services of validation events:
- Register webhook endpoints
- Define event types (validation complete, bulk complete, etc.)
- Implement retry mechanism with exponential backoff
- HMAC signature verification for security
- Webhook logs and management UI

---

## Implementation Steps

### Step 1: Create Webhook Types

Create `src/lib/webhooks/types.ts`:

```typescript
export interface Webhook {
  id: string;
  url: string;
  secret: string;
  events: WebhookEventType[];
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
  lastTriggeredAt?: Date;
  failureCount: number;
}

export type WebhookEventType =
  | 'validation.complete'
  | 'validation.failed'
  | 'bulk.complete'
  | 'bulk.progress';

export interface WebhookPayload {
  event: WebhookEventType;
  timestamp: string;
  data: WebhookEventData;
}

export type WebhookEventData =
  | ValidationCompleteData
  | ValidationFailedData
  | BulkCompleteData
  | BulkProgressData;

export interface ValidationCompleteData {
  email: string;
  result: {
    valid: boolean;
    score: number;
    deliverability: string;
    risk: string;
  };
  validatedAt: string;
}

export interface ValidationFailedData {
  email: string;
  error: string;
  failedAt: string;
}

export interface BulkCompleteData {
  batchId: string;
  totalEmails: number;
  validCount: number;
  invalidCount: number;
  completedAt: string;
}

export interface BulkProgressData {
  batchId: string;
  totalEmails: number;
  processedEmails: number;
  progress: number;
}

export interface WebhookDelivery {
  id: string;
  webhookId: string;
  event: WebhookEventType;
  payload: WebhookPayload;
  status: 'pending' | 'success' | 'failed';
  attempts: number;
  lastAttemptAt?: Date;
  responseStatus?: number;
  responseBody?: string;
  error?: string;
  createdAt: Date;
}

export interface WebhookConfig {
  maxRetries: number;
  retryDelayMs: number;
  timeoutMs: number;
}
```

### Step 2: Create Webhook Signature

Create `src/lib/webhooks/signature.ts`:

```typescript
import crypto from 'crypto';

const SIGNATURE_HEADER = 'X-Webhook-Signature';
const TIMESTAMP_HEADER = 'X-Webhook-Timestamp';

/**
 * Generate HMAC signature for webhook payload
 */
export function generateSignature(
  payload: string,
  secret: string,
  timestamp: number
): string {
  const signaturePayload = `${timestamp}.${payload}`;
  const signature = crypto
    .createHmac('sha256', secret)
    .update(signaturePayload)
    .digest('hex');

  return `v1=${signature}`;
}

/**
 * Verify webhook signature
 */
export function verifySignature(
  payload: string,
  signature: string,
  secret: string,
  timestamp: number,
  toleranceMs: number = 300000 // 5 minutes
): boolean {
  // Check timestamp tolerance
  const now = Date.now();
  if (Math.abs(now - timestamp) > toleranceMs) {
    return false;
  }

  // Generate expected signature
  const expectedSignature = generateSignature(payload, secret, timestamp);

  // Constant-time comparison
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}

/**
 * Get signature headers for webhook request
 */
export function getSignatureHeaders(
  payload: string,
  secret: string
): Record<string, string> {
  const timestamp = Date.now();
  const signature = generateSignature(payload, secret, timestamp);

  return {
    [SIGNATURE_HEADER]: signature,
    [TIMESTAMP_HEADER]: timestamp.toString(),
  };
}

export { SIGNATURE_HEADER, TIMESTAMP_HEADER };
```

### Step 3: Create Webhook Sender

Create `src/lib/webhooks/sender.ts`:

```typescript
import { Webhook, WebhookPayload, WebhookDelivery, WebhookConfig } from './types';
import { getSignatureHeaders } from './signature';

const DEFAULT_CONFIG: WebhookConfig = {
  maxRetries: 3,
  retryDelayMs: 1000,
  timeoutMs: 10000,
};

/**
 * Send webhook with retry logic
 */
export async function sendWebhook(
  webhook: Webhook,
  payload: WebhookPayload,
  config: Partial<WebhookConfig> = {}
): Promise<WebhookDelivery> {
  const fullConfig = { ...DEFAULT_CONFIG, ...config };
  const payloadString = JSON.stringify(payload);
  const deliveryId = generateId();

  const delivery: WebhookDelivery = {
    id: deliveryId,
    webhookId: webhook.id,
    event: payload.event,
    payload,
    status: 'pending',
    attempts: 0,
    createdAt: new Date(),
  };

  for (let attempt = 0; attempt <= fullConfig.maxRetries; attempt++) {
    try {
      delivery.attempts++;
      delivery.lastAttemptAt = new Date();

      const headers = {
        'Content-Type': 'application/json',
        'User-Agent': 'EmailValidator-Webhook/1.0',
        ...getSignatureHeaders(payloadString, webhook.secret),
      };

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), fullConfig.timeoutMs);

      const response = await fetch(webhook.url, {
        method: 'POST',
        headers,
        body: payloadString,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      delivery.responseStatus = response.status;

      if (response.ok) {
        delivery.status = 'success';
        delivery.responseBody = await response.text().catch(() => '');
        return delivery;
      }

      // Non-2xx response
      delivery.error = `HTTP ${response.status}`;
      delivery.responseBody = await response.text().catch(() => '');

    } catch (error) {
      delivery.error = error instanceof Error ? error.message : 'Unknown error';
    }

    // Wait before retry (exponential backoff)
    if (attempt < fullConfig.maxRetries) {
      const delay = fullConfig.retryDelayMs * Math.pow(2, attempt);
      await sleep(delay);
    }
  }

  delivery.status = 'failed';
  return delivery;
}

/**
 * Send to multiple webhooks
 */
export async function broadcastWebhook(
  webhooks: Webhook[],
  payload: WebhookPayload
): Promise<WebhookDelivery[]> {
  const activeWebhooks = webhooks.filter(
    (w) => w.isActive && w.events.includes(payload.event)
  );

  const deliveries = await Promise.all(
    activeWebhooks.map((webhook) => sendWebhook(webhook, payload))
  );

  return deliveries;
}

function generateId(): string {
  return `del_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
```

### Step 4: Create Webhook Store

Create `src/stores/webhook-store.ts`:

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { Webhook, WebhookDelivery, WebhookEventType } from '@/lib/webhooks/types';
import crypto from 'crypto';

interface WebhookState {
  webhooks: Webhook[];
  deliveries: WebhookDelivery[];

  // Webhook CRUD
  createWebhook: (url: string, events: WebhookEventType[]) => Webhook;
  updateWebhook: (id: string, updates: Partial<Webhook>) => void;
  deleteWebhook: (id: string) => void;
  getWebhook: (id: string) => Webhook | undefined;

  // Delivery tracking
  addDelivery: (delivery: WebhookDelivery) => void;
  getDeliveries: (webhookId?: string) => WebhookDelivery[];
  clearDeliveries: (webhookId?: string) => void;

  // Webhook management
  toggleWebhook: (id: string) => void;
  regenerateSecret: (id: string) => string;
  resetFailureCount: (id: string) => void;
}

const generateId = () => `wh_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
const generateSecret = () => `whsec_${crypto.randomBytes(24).toString('hex')}`;

export const useWebhookStore = create<WebhookState>()(
  persist(
    (set, get) => ({
      webhooks: [],
      deliveries: [],

      createWebhook: (url, events) => {
        const newWebhook: Webhook = {
          id: generateId(),
          url,
          secret: generateSecret(),
          events,
          isActive: true,
          createdAt: new Date(),
          updatedAt: new Date(),
          failureCount: 0,
        };

        set((state) => ({
          webhooks: [...state.webhooks, newWebhook],
        }));

        return newWebhook;
      },

      updateWebhook: (id, updates) => {
        set((state) => ({
          webhooks: state.webhooks.map((w) =>
            w.id === id ? { ...w, ...updates, updatedAt: new Date() } : w
          ),
        }));
      },

      deleteWebhook: (id) => {
        set((state) => ({
          webhooks: state.webhooks.filter((w) => w.id !== id),
          deliveries: state.deliveries.filter((d) => d.webhookId !== id),
        }));
      },

      getWebhook: (id) => {
        return get().webhooks.find((w) => w.id === id);
      },

      addDelivery: (delivery) => {
        set((state) => ({
          deliveries: [delivery, ...state.deliveries].slice(0, 100), // Keep last 100
        }));

        // Update webhook last triggered and failure count
        const webhook = get().getWebhook(delivery.webhookId);
        if (webhook) {
          get().updateWebhook(delivery.webhookId, {
            lastTriggeredAt: new Date(),
            failureCount:
              delivery.status === 'failed'
                ? webhook.failureCount + 1
                : 0,
          });
        }
      },

      getDeliveries: (webhookId) => {
        const deliveries = get().deliveries;
        return webhookId
          ? deliveries.filter((d) => d.webhookId === webhookId)
          : deliveries;
      },

      clearDeliveries: (webhookId) => {
        set((state) => ({
          deliveries: webhookId
            ? state.deliveries.filter((d) => d.webhookId !== webhookId)
            : [],
        }));
      },

      toggleWebhook: (id) => {
        set((state) => ({
          webhooks: state.webhooks.map((w) =>
            w.id === id ? { ...w, isActive: !w.isActive, updatedAt: new Date() } : w
          ),
        }));
      },

      regenerateSecret: (id) => {
        const newSecret = generateSecret();
        get().updateWebhook(id, { secret: newSecret });
        return newSecret;
      },

      resetFailureCount: (id) => {
        get().updateWebhook(id, { failureCount: 0 });
      },
    }),
    {
      name: 'email-validator-webhooks',
      partialize: (state) => ({
        webhooks: state.webhooks,
        deliveries: state.deliveries.slice(0, 50), // Only persist last 50 deliveries
      }),
    }
  )
);
```

### Step 5: Create Webhook API Routes

Create `src/app/api/webhooks/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

const createWebhookSchema = z.object({
  url: z.string().url(),
  events: z.array(z.enum([
    'validation.complete',
    'validation.failed',
    'bulk.complete',
    'bulk.progress',
  ])).min(1),
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const validated = createWebhookSchema.parse(body);

    // In a real app, this would be stored in a database
    // For now, return a mock response
    const webhook = {
      id: `wh_${Date.now()}`,
      url: validated.url,
      events: validated.events,
      secret: `whsec_${crypto.randomUUID()}`,
      isActive: true,
      createdAt: new Date().toISOString(),
    };

    return NextResponse.json({
      success: true,
      webhook,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: 'Invalid request', details: error.errors },
        { status: 400 }
      );
    }
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function GET() {
  // Return list of webhooks (for API docs)
  return NextResponse.json({
    success: true,
    webhooks: [],
    message: 'Webhook management is handled client-side in localStorage',
  });
}
```

Create `src/app/api/webhooks/test/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { sendWebhook } from '@/lib/webhooks/sender';
import { Webhook, WebhookPayload } from '@/lib/webhooks/types';

export async function POST(request: NextRequest) {
  try {
    const { url, secret, event } = await request.json();

    if (!url || !secret) {
      return NextResponse.json(
        { success: false, error: 'URL and secret are required' },
        { status: 400 }
      );
    }

    const testWebhook: Webhook = {
      id: 'test',
      url,
      secret,
      events: [event || 'validation.complete'],
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      failureCount: 0,
    };

    const testPayload: WebhookPayload = {
      event: event || 'validation.complete',
      timestamp: new Date().toISOString(),
      data: {
        email: 'test@example.com',
        result: {
          valid: true,
          score: 95,
          deliverability: 'deliverable',
          risk: 'low',
        },
        validatedAt: new Date().toISOString(),
      },
    };

    const delivery = await sendWebhook(testWebhook, testPayload, {
      maxRetries: 0, // No retries for test
      timeoutMs: 5000,
    });

    return NextResponse.json({
      success: delivery.status === 'success',
      delivery,
    });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: error instanceof Error ? error.message : 'Test failed' },
      { status: 500 }
    );
  }
}
```

### Step 6: Create Webhook Management UI

Create `src/components/webhooks/WebhookManager.tsx`:

```typescript
'use client';

import { useState } from 'react';
import { useWebhookStore } from '@/stores/webhook-store';
import { WebhookEventType } from '@/lib/webhooks/types';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Checkbox } from '@/components/ui/checkbox';
import {
  Webhook,
  Plus,
  Trash2,
  RefreshCw,
  Eye,
  EyeOff,
  Send,
  CheckCircle,
  XCircle,
  Clock,
} from 'lucide-react';

const EVENT_OPTIONS: { value: WebhookEventType; label: string }[] = [
  { value: 'validation.complete', label: 'Validation Complete' },
  { value: 'validation.failed', label: 'Validation Failed' },
  { value: 'bulk.complete', label: 'Bulk Complete' },
  { value: 'bulk.progress', label: 'Bulk Progress' },
];

export function WebhookManager() {
  const {
    webhooks,
    deliveries,
    createWebhook,
    deleteWebhook,
    toggleWebhook,
    regenerateSecret,
    getDeliveries,
  } = useWebhookStore();

  const [newUrl, setNewUrl] = useState('');
  const [selectedEvents, setSelectedEvents] = useState<WebhookEventType[]>([]);
  const [showSecrets, setShowSecrets] = useState<Record<string, boolean>>({});
  const [testing, setTesting] = useState<string | null>(null);

  const handleCreate = () => {
    if (!newUrl || selectedEvents.length === 0) return;
    createWebhook(newUrl, selectedEvents);
    setNewUrl('');
    setSelectedEvents([]);
  };

  const handleTest = async (webhookId: string) => {
    const webhook = webhooks.find((w) => w.id === webhookId);
    if (!webhook) return;

    setTesting(webhookId);
    try {
      await fetch('/api/webhooks/test', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          url: webhook.url,
          secret: webhook.secret,
          event: webhook.events[0],
        }),
      });
    } finally {
      setTesting(null);
    }
  };

  const toggleEventSelection = (event: WebhookEventType) => {
    setSelectedEvents((prev) =>
      prev.includes(event)
        ? prev.filter((e) => e !== event)
        : [...prev, event]
    );
  };

  return (
    <div className="space-y-6">
      {/* Create Webhook */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Webhook className="h-5 w-5" />
            Add Webhook
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <Input
            placeholder="https://your-server.com/webhook"
            value={newUrl}
            onChange={(e) => setNewUrl(e.target.value)}
          />

          <div className="space-y-2">
            <label className="text-sm font-medium">Events</label>
            <div className="flex flex-wrap gap-2">
              {EVENT_OPTIONS.map((option) => (
                <label
                  key={option.value}
                  className="flex items-center gap-2 cursor-pointer"
                >
                  <Checkbox
                    checked={selectedEvents.includes(option.value)}
                    onCheckedChange={() => toggleEventSelection(option.value)}
                  />
                  <span className="text-sm">{option.label}</span>
                </label>
              ))}
            </div>
          </div>

          <Button onClick={handleCreate} disabled={!newUrl || selectedEvents.length === 0}>
            <Plus className="h-4 w-4 mr-2" />
            Add Webhook
          </Button>
        </CardContent>
      </Card>

      {/* Webhook List */}
      {webhooks.map((webhook) => (
        <Card key={webhook.id}>
          <CardContent className="pt-6">
            <div className="space-y-4">
              {/* URL and Status */}
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <Badge variant={webhook.isActive ? 'default' : 'secondary'}>
                    {webhook.isActive ? 'Active' : 'Inactive'}
                  </Badge>
                  <span className="font-mono text-sm truncate max-w-md">
                    {webhook.url}
                  </span>
                </div>
                <div className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => handleTest(webhook.id)}
                    disabled={testing === webhook.id}
                  >
                    {testing === webhook.id ? (
                      <RefreshCw className="h-4 w-4 animate-spin" />
                    ) : (
                      <Send className="h-4 w-4" />
                    )}
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => toggleWebhook(webhook.id)}
                  >
                    {webhook.isActive ? 'Disable' : 'Enable'}
                  </Button>
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={() => deleteWebhook(webhook.id)}
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </div>
              </div>

              {/* Secret */}
              <div className="flex items-center gap-2">
                <span className="text-sm text-muted-foreground">Secret:</span>
                <code className="text-sm bg-muted px-2 py-1 rounded">
                  {showSecrets[webhook.id]
                    ? webhook.secret
                    : '••••••••••••••••'}
                </code>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={() =>
                    setShowSecrets((prev) => ({
                      ...prev,
                      [webhook.id]: !prev[webhook.id],
                    }))
                  }
                >
                  {showSecrets[webhook.id] ? (
                    <EyeOff className="h-4 w-4" />
                  ) : (
                    <Eye className="h-4 w-4" />
                  )}
                </Button>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={() => regenerateSecret(webhook.id)}
                >
                  <RefreshCw className="h-4 w-4" />
                </Button>
              </div>

              {/* Events */}
              <div className="flex flex-wrap gap-1">
                {webhook.events.map((event) => (
                  <Badge key={event} variant="outline">
                    {event}
                  </Badge>
                ))}
              </div>

              {/* Recent Deliveries */}
              <div className="border-t pt-4 mt-4">
                <h4 className="text-sm font-medium mb-2">Recent Deliveries</h4>
                <div className="space-y-1">
                  {getDeliveries(webhook.id).slice(0, 5).map((delivery) => (
                    <div
                      key={delivery.id}
                      className="flex items-center justify-between text-sm"
                    >
                      <div className="flex items-center gap-2">
                        {delivery.status === 'success' ? (
                          <CheckCircle className="h-4 w-4 text-green-500" />
                        ) : delivery.status === 'failed' ? (
                          <XCircle className="h-4 w-4 text-red-500" />
                        ) : (
                          <Clock className="h-4 w-4 text-yellow-500" />
                        )}
                        <span>{delivery.event}</span>
                      </div>
                      <span className="text-muted-foreground">
                        {delivery.responseStatus && `HTTP ${delivery.responseStatus}`}
                      </span>
                    </div>
                  ))}
                  {getDeliveries(webhook.id).length === 0 && (
                    <p className="text-sm text-muted-foreground">No deliveries yet</p>
                  )}
                </div>
              </div>
            </div>
          </CardContent>
        </Card>
      ))}

      {webhooks.length === 0 && (
        <p className="text-center text-muted-foreground py-8">
          No webhooks configured. Add one above to receive notifications.
        </p>
      )}
    </div>
  );
}
```

### Step 7: Create Webhook Index

Create `src/lib/webhooks/index.ts`:

```typescript
export { sendWebhook, broadcastWebhook } from './sender';
export { generateSignature, verifySignature, getSignatureHeaders } from './signature';
export * from './types';
```

### Step 8: Write Tests

Create `src/__tests__/lib/webhooks/webhooks.test.ts`:

```typescript
import { generateSignature, verifySignature } from '@/lib/webhooks/signature';
import { sendWebhook } from '@/lib/webhooks/sender';
import { Webhook, WebhookPayload } from '@/lib/webhooks/types';

// Mock fetch
global.fetch = jest.fn();

describe('Webhooks', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('Signature', () => {
    const secret = 'test-secret';
    const payload = '{"test":"data"}';
    const timestamp = 1700000000000;

    test('generates consistent signatures', () => {
      const sig1 = generateSignature(payload, secret, timestamp);
      const sig2 = generateSignature(payload, secret, timestamp);

      expect(sig1).toBe(sig2);
      expect(sig1).toMatch(/^v1=[a-f0-9]{64}$/);
    });

    test('generates different signatures for different payloads', () => {
      const sig1 = generateSignature('payload1', secret, timestamp);
      const sig2 = generateSignature('payload2', secret, timestamp);

      expect(sig1).not.toBe(sig2);
    });

    test('verifies valid signature', () => {
      const signature = generateSignature(payload, secret, timestamp);
      const isValid = verifySignature(payload, signature, secret, timestamp, Infinity);

      expect(isValid).toBe(true);
    });

    test('rejects invalid signature', () => {
      const isValid = verifySignature(payload, 'v1=invalid', secret, timestamp, Infinity);

      expect(isValid).toBe(false);
    });

    test('rejects expired timestamp', () => {
      const oldTimestamp = Date.now() - 600000; // 10 minutes ago
      const signature = generateSignature(payload, secret, oldTimestamp);
      const isValid = verifySignature(payload, signature, secret, oldTimestamp, 300000);

      expect(isValid).toBe(false);
    });
  });

  describe('sendWebhook', () => {
    const webhook: Webhook = {
      id: 'test-webhook',
      url: 'https://example.com/webhook',
      secret: 'test-secret',
      events: ['validation.complete'],
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      failureCount: 0,
    };

    const payload: WebhookPayload = {
      event: 'validation.complete',
      timestamp: new Date().toISOString(),
      data: {
        email: 'test@example.com',
        result: {
          valid: true,
          score: 95,
          deliverability: 'deliverable',
          risk: 'low',
        },
        validatedAt: new Date().toISOString(),
      },
    };

    test('sends webhook successfully', async () => {
      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        status: 200,
        text: () => Promise.resolve('OK'),
      });

      const delivery = await sendWebhook(webhook, payload, { maxRetries: 0 });

      expect(delivery.status).toBe('success');
      expect(delivery.responseStatus).toBe(200);
      expect(fetch).toHaveBeenCalledTimes(1);
    });

    test('retries on failure', async () => {
      (fetch as jest.Mock)
        .mockRejectedValueOnce(new Error('Network error'))
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          text: () => Promise.resolve('OK'),
        });

      const delivery = await sendWebhook(webhook, payload, {
        maxRetries: 1,
        retryDelayMs: 10,
      });

      expect(delivery.status).toBe('success');
      expect(delivery.attempts).toBe(2);
    });

    test('marks as failed after max retries', async () => {
      (fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

      const delivery = await sendWebhook(webhook, payload, {
        maxRetries: 2,
        retryDelayMs: 10,
      });

      expect(delivery.status).toBe('failed');
      expect(delivery.attempts).toBe(3);
      expect(delivery.error).toBe('Network error');
    });

    test('includes correct headers', async () => {
      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        status: 200,
        text: () => Promise.resolve('OK'),
      });

      await sendWebhook(webhook, payload, { maxRetries: 0 });

      const call = (fetch as jest.Mock).mock.calls[0];
      const headers = call[1].headers;

      expect(headers['Content-Type']).toBe('application/json');
      expect(headers['X-Webhook-Signature']).toMatch(/^v1=/);
      expect(headers['X-Webhook-Timestamp']).toBeTruthy();
    });
  });
});
```

---

## Completion Checklist

```
[ ] Webhook types defined
[ ] HMAC signature generation
[ ] Signature verification
[ ] Webhook sender with retries
[ ] Exponential backoff
[ ] Webhook store created
[ ] CRUD operations
[ ] Delivery tracking
[ ] API routes created
[ ] Test endpoint created
[ ] Management UI created
[ ] Secret show/hide toggle
[ ] Secret regeneration
[ ] Delivery logs display
[ ] Tests written and passing
[ ] All existing tests pass
[ ] Changes committed and pushed
```

---

## Next Milestone

After completing this milestone, proceed to:
`plans/milestones/8.2-api-dashboard.md`
