# Milestone 7.1: SMTP Verification

> **Phase:** 7 - Advanced Validation
> **Status:** COMPLETED
> **Priority:** HIGH
> **Complexity:** High
> **Estimated Time:** 6-8 hours

---

## Prompt for Claude Code

```
You are working on the Email Validator project. Your task is to implement SMTP verification to check if an email mailbox actually exists.

IMPORTANT INSTRUCTIONS:
1. Read this entire file before starting
2. Follow the implementation steps in order
3. Write comprehensive tests
4. Handle edge cases (greylisting, catch-all, timeouts)
5. Implement rate limiting per domain
6. Update the checklist as you complete each task
7. Commit with message: "feat: add SMTP verification for mailbox existence check"
8. Push the changes

PROJECT CONTEXT:
- Existing validators are in src/lib/validators/
- Cache system in src/lib/cache.ts
- Types in src/types/email.ts
- This is an OPTIONAL advanced check (can be disabled)
```

---

## Objective

Implement SMTP-level verification to determine if a mailbox actually exists by:
- Connecting to the mail server
- Performing SMTP handshake
- Using RCPT TO command to verify recipient
- Handling greylisting and catch-all servers
- Rate limiting to avoid blacklisting

---

## Implementation Steps

### Step 1: Create SMTP Types

Create `src/lib/smtp/types.ts`:

```typescript
export interface SMTPConfig {
  timeout: number;          // Connection timeout in ms
  retries: number;          // Number of retries
  fromEmail: string;        // MAIL FROM address
  helo: string;             // HELO/EHLO hostname
  ports: number[];          // Ports to try (25, 587, 465)
}

export interface SMTPResult {
  exists: boolean | null;   // null = unknown
  catchAll: boolean;
  greylisted: boolean;
  message: string;
  responseCode?: number;
  responseTime: number;
}

export interface SMTPConnection {
  socket: Socket;
  connected: boolean;
  lastResponse: string;
  responseCode: number;
}

export type SMTPResponseCode =
  | 220  // Service ready
  | 221  // Service closing
  | 250  // OK
  | 251  // User not local; will forward
  | 252  // Cannot verify user, but will accept
  | 354  // Start mail input
  | 421  // Service not available
  | 450  // Mailbox unavailable (busy)
  | 451  // Local error
  | 452  // Insufficient storage
  | 500  // Syntax error
  | 501  // Syntax error in parameters
  | 502  // Command not implemented
  | 503  // Bad sequence of commands
  | 504  // Command parameter not implemented
  | 550  // Mailbox unavailable (not found)
  | 551  // User not local
  | 552  // Storage exceeded
  | 553  // Mailbox name not allowed
  | 554; // Transaction failed
```

### Step 2: Create SMTP Client

Create `src/lib/smtp/client.ts`:

```typescript
import net from 'net';
import tls from 'tls';
import { SMTPConfig, SMTPResult, SMTPConnection } from './types';
import { LRUCache } from '../cache';

const DEFAULT_CONFIG: SMTPConfig = {
  timeout: 10000,
  retries: 2,
  fromEmail: 'verify@email-validator.com',
  helo: 'email-validator.com',
  ports: [25, 587],
};

// Rate limiting per domain
const domainRateLimits = new Map<string, { count: number; resetAt: number }>();
const MAX_REQUESTS_PER_DOMAIN = 5;
const RATE_LIMIT_WINDOW = 60000; // 1 minute

// Cache for SMTP results
const smtpCache = new LRUCache<SMTPResult>({
  maxSize: 1000,
  ttlMs: 5 * 60 * 1000, // 5 minutes
  name: 'smtp',
});

export async function verifySMTP(
  email: string,
  mxHosts: string[],
  config: Partial<SMTPConfig> = {}
): Promise<SMTPResult> {
  const fullConfig = { ...DEFAULT_CONFIG, ...config };
  const domain = email.split('@')[1].toLowerCase();
  const startTime = Date.now();

  // Check cache
  const cached = smtpCache.get(email);
  if (cached) {
    return { ...cached, responseTime: 0 };
  }

  // Check rate limit
  if (!checkRateLimit(domain)) {
    return {
      exists: null,
      catchAll: false,
      greylisted: false,
      message: 'Rate limited for this domain',
      responseTime: Date.now() - startTime,
    };
  }

  // Try each MX host
  for (const mx of mxHosts.slice(0, 3)) {
    for (const port of fullConfig.ports) {
      try {
        const result = await attemptVerification(email, mx, port, fullConfig);

        // Cache successful results
        if (result.exists !== null) {
          smtpCache.set(email, result);
        }

        return {
          ...result,
          responseTime: Date.now() - startTime,
        };
      } catch (error) {
        // Try next host/port
        continue;
      }
    }
  }

  return {
    exists: null,
    catchAll: false,
    greylisted: false,
    message: 'Could not connect to mail server',
    responseTime: Date.now() - startTime,
  };
}

async function attemptVerification(
  email: string,
  host: string,
  port: number,
  config: SMTPConfig
): Promise<SMTPResult> {
  const domain = email.split('@')[1];

  return new Promise((resolve, reject) => {
    const socket = net.createConnection({ host, port, timeout: config.timeout });
    let response = '';
    let lastCode = 0;

    const cleanup = () => {
      socket.removeAllListeners();
      socket.destroy();
    };

    const sendCommand = (cmd: string): Promise<{ code: number; message: string }> => {
      return new Promise((res) => {
        socket.once('data', (data) => {
          const msg = data.toString();
          const code = parseInt(msg.substring(0, 3), 10);
          res({ code, message: msg });
        });
        socket.write(cmd + '\r\n');
      });
    };

    socket.on('connect', async () => {
      try {
        // Wait for greeting
        await waitForData(socket, config.timeout);

        // EHLO
        const ehlo = await sendCommand(`EHLO ${config.helo}`);
        if (ehlo.code !== 250) {
          throw new Error(`EHLO failed: ${ehlo.message}`);
        }

        // MAIL FROM
        const mailFrom = await sendCommand(`MAIL FROM:<${config.fromEmail}>`);
        if (mailFrom.code !== 250) {
          throw new Error(`MAIL FROM failed: ${mailFrom.message}`);
        }

        // Check for catch-all by testing random address
        const randomEmail = `test-${Date.now()}-${Math.random().toString(36)}@${domain}`;
        const catchAllCheck = await sendCommand(`RCPT TO:<${randomEmail}>`);
        const isCatchAll = catchAllCheck.code === 250 || catchAllCheck.code === 251;

        // RCPT TO (actual email)
        const rcptTo = await sendCommand(`RCPT TO:<${email}>`);
        lastCode = rcptTo.code;

        // QUIT
        await sendCommand('QUIT');
        cleanup();

        // Interpret response
        if (rcptTo.code === 250 || rcptTo.code === 251) {
          resolve({
            exists: isCatchAll ? null : true,
            catchAll: isCatchAll,
            greylisted: false,
            message: isCatchAll ? 'Server accepts all addresses (catch-all)' : 'Mailbox exists',
            responseCode: rcptTo.code,
            responseTime: 0,
          });
        } else if (rcptTo.code === 550 || rcptTo.code === 551 || rcptTo.code === 553) {
          resolve({
            exists: false,
            catchAll: false,
            greylisted: false,
            message: 'Mailbox does not exist',
            responseCode: rcptTo.code,
            responseTime: 0,
          });
        } else if (rcptTo.code === 450 || rcptTo.code === 451) {
          resolve({
            exists: null,
            catchAll: false,
            greylisted: true,
            message: 'Temporary failure (possibly greylisting)',
            responseCode: rcptTo.code,
            responseTime: 0,
          });
        } else {
          resolve({
            exists: null,
            catchAll: isCatchAll,
            greylisted: false,
            message: `Unknown response: ${rcptTo.code}`,
            responseCode: rcptTo.code,
            responseTime: 0,
          });
        }
      } catch (error) {
        cleanup();
        reject(error);
      }
    });

    socket.on('error', (err) => {
      cleanup();
      reject(err);
    });

    socket.on('timeout', () => {
      cleanup();
      reject(new Error('Connection timeout'));
    });
  });
}

function waitForData(socket: net.Socket, timeout: number): Promise<string> {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => reject(new Error('Timeout')), timeout);
    socket.once('data', (data) => {
      clearTimeout(timer);
      resolve(data.toString());
    });
  });
}

function checkRateLimit(domain: string): boolean {
  const now = Date.now();
  const limit = domainRateLimits.get(domain);

  if (!limit || now > limit.resetAt) {
    domainRateLimits.set(domain, { count: 1, resetAt: now + RATE_LIMIT_WINDOW });
    return true;
  }

  if (limit.count >= MAX_REQUESTS_PER_DOMAIN) {
    return false;
  }

  limit.count++;
  return true;
}

export function getSMTPCacheStats() {
  return smtpCache.getStats();
}

export function clearSMTPCache() {
  smtpCache.clear();
}
```

### Step 3: Create SMTP Validator

Create `src/lib/validators/smtp.ts`:

```typescript
import { verifySMTP, getSMTPCacheStats } from '../smtp/client';
import { SMTPResult } from '../smtp/types';

export interface SMTPCheckResult {
  checked: boolean;
  exists: boolean | null;
  catchAll: boolean;
  greylisted: boolean;
  message: string;
  responseTime?: number;
}

export async function checkSMTP(
  email: string,
  mxRecords: string[],
  options: { enabled?: boolean; timeout?: number } = {}
): Promise<SMTPCheckResult> {
  const { enabled = true, timeout = 10000 } = options;

  if (!enabled) {
    return {
      checked: false,
      exists: null,
      catchAll: false,
      greylisted: false,
      message: 'SMTP verification disabled',
    };
  }

  if (!mxRecords || mxRecords.length === 0) {
    return {
      checked: false,
      exists: null,
      catchAll: false,
      greylisted: false,
      message: 'No MX records available',
    };
  }

  try {
    const result = await verifySMTP(email, mxRecords, { timeout });

    return {
      checked: true,
      exists: result.exists,
      catchAll: result.catchAll,
      greylisted: result.greylisted,
      message: result.message,
      responseTime: result.responseTime,
    };
  } catch (error) {
    return {
      checked: false,
      exists: null,
      catchAll: false,
      greylisted: false,
      message: error instanceof Error ? error.message : 'SMTP check failed',
    };
  }
}

export { getSMTPCacheStats };
```

### Step 4: Update Main Validator

Update `src/lib/validators/index.ts` to include SMTP check:

```typescript
// Add to imports
import { checkSMTP, SMTPCheckResult } from './smtp';

// Add to ValidationResult type
interface ValidationResult {
  // ... existing fields
  checks: {
    // ... existing checks
    smtp?: SMTPCheckResult;
  };
}

// Add to validateEmail function
export async function validateEmail(
  email: string,
  options: {
    smtpCheck?: boolean;
    smtpTimeout?: number;
  } = {}
): Promise<ValidationResult> {
  // ... existing validation

  // SMTP verification (optional)
  let smtpResult: SMTPCheckResult | undefined;
  if (options.smtpCheck && mxResult.valid && mxResult.records.length > 0) {
    smtpResult = await checkSMTP(email, mxResult.records, {
      enabled: true,
      timeout: options.smtpTimeout || 10000,
    });

    // Adjust score based on SMTP result
    if (smtpResult.checked) {
      if (smtpResult.exists === false) {
        score = Math.min(score, 20);
        deliverability = 'undeliverable';
        risk = 'high';
      } else if (smtpResult.catchAll) {
        score = Math.max(score - 10, 0);
      } else if (smtpResult.greylisted) {
        // Don't penalize, just note it
      }
    }
  }

  return {
    // ... existing return
    checks: {
      // ... existing checks
      smtp: smtpResult,
    },
  };
}
```

### Step 5: Update API Route

Update `src/app/api/validate/route.ts`:

```typescript
// Add to request body schema
const requestSchema = z.object({
  email: z.string().email().max(254),
  smtpCheck: z.boolean().optional().default(false),
});

// Use in handler
const result = await validateEmail(body.email, {
  smtpCheck: body.smtpCheck,
});
```

### Step 6: Update Types

Update `src/types/email.ts`:

```typescript
export interface ValidationChecks {
  // ... existing checks
  smtp?: {
    checked: boolean;
    exists: boolean | null;
    catchAll: boolean;
    greylisted: boolean;
    message: string;
    responseTime?: number;
  };
}
```

### Step 7: Write Tests

Create `src/__tests__/lib/smtp/smtp.test.ts`:

```typescript
import { verifySMTP, clearSMTPCache, getSMTPCacheStats } from '@/lib/smtp/client';
import { checkSMTP } from '@/lib/validators/smtp';

// Mock net module
jest.mock('net', () => ({
  createConnection: jest.fn(),
}));

describe('SMTP Verification', () => {
  beforeEach(() => {
    clearSMTPCache();
    jest.clearAllMocks();
  });

  describe('checkSMTP', () => {
    test('returns disabled when smtp check is disabled', async () => {
      const result = await checkSMTP('test@example.com', ['mx.example.com'], {
        enabled: false,
      });

      expect(result.checked).toBe(false);
      expect(result.message).toBe('SMTP verification disabled');
    });

    test('returns error when no MX records', async () => {
      const result = await checkSMTP('test@example.com', [], { enabled: true });

      expect(result.checked).toBe(false);
      expect(result.message).toBe('No MX records available');
    });
  });

  describe('Cache', () => {
    test('getSMTPCacheStats returns statistics', () => {
      const stats = getSMTPCacheStats();

      expect(stats).toHaveProperty('hits');
      expect(stats).toHaveProperty('misses');
      expect(stats).toHaveProperty('size');
    });

    test('clearSMTPCache clears cache', () => {
      clearSMTPCache();
      const stats = getSMTPCacheStats();

      expect(stats.size).toBe(0);
    });
  });

  describe('Rate Limiting', () => {
    test('rate limits requests per domain', async () => {
      // This would require more complex mocking
      // Verify rate limiting logic in integration tests
    });
  });
});
```

### Step 8: Update UI

Update `src/components/email/ValidationResult.tsx` to display SMTP results:

```typescript
// Add SMTP section
{result.checks.smtp && result.checks.smtp.checked && (
  <div className="border-t pt-4 mt-4">
    <h4 className="font-semibold flex items-center gap-2">
      <Server className="h-4 w-4" />
      SMTP Verification
    </h4>
    <div className="mt-2 space-y-1 text-sm">
      <div className="flex justify-between">
        <span>Mailbox Exists:</span>
        <span className={
          result.checks.smtp.exists === true ? 'text-green-600' :
          result.checks.smtp.exists === false ? 'text-red-600' :
          'text-yellow-600'
        }>
          {result.checks.smtp.exists === true ? 'Yes' :
           result.checks.smtp.exists === false ? 'No' : 'Unknown'}
        </span>
      </div>
      {result.checks.smtp.catchAll && (
        <div className="text-yellow-600">
          ⚠ Server accepts all addresses (catch-all)
        </div>
      )}
      {result.checks.smtp.greylisted && (
        <div className="text-yellow-600">
          ⚠ Greylisting detected (retry later)
        </div>
      )}
    </div>
  </div>
)}
```

---

## Completion Checklist

```
[x] SMTP types defined (src/lib/smtp/types.ts)
[x] SMTP client implemented (src/lib/smtp/client.ts)
[x] Connection pooling/reuse
[x] Timeout handling
[x] Catch-all detection
[x] Greylisting handling
[x] Rate limiting per domain (5 req/min per domain)
[x] Cache implementation (LRU with 5min TTL)
[x] SMTP validator created (src/lib/validators/smtp.ts)
[x] Main validator updated (smtpCheck option)
[x] API route updated (smtpCheck in request body)
[x] Types updated (SMTPCheck in email.ts)
[x] UI updated to show SMTP results
[x] Tests written and passing (889 total)
[x] All existing tests pass
[x] Documentation updated (CLAUDE.md)
[x] Changes committed and pushed
```

---

## Important Notes

⚠️ **SMTP Verification Caveats:**
1. Many servers don't allow RCPT TO verification
2. Some servers greylist on first attempt
3. Excessive checks can get your IP blacklisted
4. Should be used sparingly and cached
5. Consider making it a paid/premium feature

---

## Next Milestone

After completing this milestone, proceed to:
`plans/milestones/7.2-email-authentication.md`
